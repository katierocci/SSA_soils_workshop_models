---
title: "MIMICS model fit"
author: "Katherine Rocci"
date: "2025-07-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Code for fitting MIMICS model to a given dataset (in this case, the afsis dataset). Requires 



#Find best model fit to data with FME
##Load V2 MMRMM
```{r}
if(do_FME_SS_V2MMRMM==1){
    model.name <- "V2.5pool.MMRMM"
    state <- c(POM = 1, LMWC = 1, AGG = 1, MIC = 1, MAOM=1)
    
#Here we fit only a subset of parameters, those which are uncommented. These parameters have a sensitivity index of < |0.25| using the sensfun function of FME. The code is in the Run Fit chunk below and is an option in Switches (do_sens_fun).
parToFit.pools <- c(#param_pi = parameters[[3]]$param_pi,
                    param_pa = parameters[[3]]$param_pa,
                    kaff_pl = parameters[[3]]$kaff_pl,
                    alpha_pl = parameters[[3]]$alpha_pl,
                    eact_pl = parameters[[3]]$eact_pl,
                    rate_pa = parameters[[3]]$rate_pa,
                    rate_break = parameters[[3]]$rate_break,
                    #rate_leach = parameters[[3]]$rate_leach,
                    #kaff_des = parameters[[3]]$kaff_des,
                    param_p1 = parameters[[3]]$param_p1,
                    #param_p2 = parameters[[3]]$param_p2,
                    kaff_lb = parameters[[3]]$kaff_lb,
                    alpha_lb = parameters[[3]]$alpha_lb, 
                    eact_lb = parameters[[3]]$eact_lb, 
                    rate_bd = parameters[[3]]$rate_bd,
                    rate_ma = parameters[[3]]$rate_ma,
                    cue_ref = parameters[[3]]$cue_ref,
                    #cue_t = parameters[[3]]$cue_t,
                    #tae_ref = parameters[[3]]$tae_ref,
                    #matpot = parameters[[3]]$matpot,
                    #lambda = parameters[[3]]$lambda,
                    porosity = parameters[[3]]$porosity,
                    #kamin = parameters[[3]]$kamin,
                    param_pb = parameters[[3]]$param_pb
                    ) 
 
parToFit.lower <- c(#param_pi = 0,
                    param_pa = 0,
                    kaff_pl = 0,
                    alpha_pl = 0,
                    eact_pl = 0,
                    rate_pa = 0,
                    rate_break = 0,
                    #rate_leach = 0,
                    #kaff_des = 0,
                    param_p1 = 0,
                    #param_p2 = 0,
                    kaff_lb = 0,
                    alpha_lb = 0, 
                    eact_lb = 0, 
                    rate_bd = 0,
                    rate_ma = 0,
                    cue_ref = 0,
                    #cue_t = -Inf,
                    #tae_ref = -Inf
                    #matpot = 0,
                    #lambda = 0,
                    porosity = 0,
                    #kamin = 0,
                    param_pb = 0
                    )
parToFit.upper <- c(#param_pi = 1,
                    param_pa = 1,
                    kaff_pl = Inf,
                    alpha_pl = Inf,
                    eact_pl = Inf,
                    rate_pa = Inf,
                    rate_break = Inf,
                    #rate_leach = Inf,
                    #kaff_des = Inf,
                    param_p1 = Inf,
                    #param_p2 = Inf,
                    kaff_lb = Inf,
                    alpha_lb = Inf, 
                    eact_lb = Inf, 
                    rate_bd = Inf,
                    rate_ma = Inf,
                    cue_ref = 1,
                    #cue_t = Inf,
                    #tae_ref = Inf
                    #matpot = Inf,
                    #lambda = Inf,
                    porosity = 1,
                    #kamin = Inf,
                    param_pb = 1
                    )

    # Definition of model derivatives
    derivs.V2.5pool.MMRMM <- function(step.num,state,parameters) {
          with(as.list(c(state,parameters)), {
            
          # Soil type properties  
            #Equation 10
            kaff_lm = exp(-parameters$param_p1 * parameters$param_pH - parameters$param_p2) * parameters$kaff_des
            
            #Equation 111
            #param_qmax = parameters$param_bulkd * parameters$param_pc * parameters$param_claysilt 
            
          # Hydrological properties
            
            #Equation 4
            scalar_wd = (parameters$forc_sw / parameters$porosity)^0.5
            
            #Equation 15
            scalar_wb = exp(parameters$lambda * -parameters$matpot) * (parameters$kamin + (1 - parameters$kamin) * ((parameters$porosity - parameters$forc_sw) / parameters$porosity)^0.5) * scalar_wd
          
          # Decomposition
            
            gas_const <- 8.31446
            
            #Equation 3
            vmax_pl = parameters$alpha_pl * exp(-parameters$eact_pl / (gas_const * (parameters$forc_st + 273.15))) 
            
            #Equation 2
            # POM -> LMWC
            if(POM>0){
              f_PO_LM = POM * vmax_pl * MIC * scalar_wd / (parameters$kaff_pl + MIC)
            }else{
              f_PO_LM=0
            }
            
            #Equation 5
            # POM -> AGG
            if(POM>0){
              f_PO_AG = parameters$rate_pa * scalar_wd * POM
            }else{
              f_PO_AG=0
            }
            
            #Equation 6
            # AGG -> MAOM + POM
            if(AGG>0){
              f_AG_break = parameters$rate_break * scalar_wd * AGG
            }else{
              f_AG_break=0
            }
            
            #Equation 8
            # LMWC -> out of system leaching
            if(LMWC>0){
              f_LM_leach = parameters$rate_leach * scalar_wd * LMWC
            }else{
              f_LM_leach=0
            }

            #Equation 9
            # LMWC -> MAOM
            if(LMWC>0 && MAOM>0){
              f_LM_MA = scalar_wd * kaff_lm * LMWC * (1 - MAOM / parameters$param_qmax)
            }else{
              f_LM_MA=0
            }
    
            #Equation 12
            # MAOM -> LMWC
            if(MAOM>0){
              f_MA_LM = parameters$kaff_des * MAOM / parameters$param_qmax
            }else{
              f_MA_LM=0
            }
            
            #Equation 14
            vmax_lb = parameters$alpha_lb * exp(-parameters$eact_lb / (gas_const * (parameters$forc_st + 273.15)))
            
            #Equation 13
            # LMWC -> MIC
            if(LMWC>0){
              f_LM_MB = vmax_lb * scalar_wb * LMWC * MIC / (parameters$kaff_lb + LMWC)
            }else{
              f_LM_MB=0
            }
            
            #Equation 16
            # MIC -> MAOM + LMWC
            if(MIC>0){
              f_MB_turn = parameters$rate_bd * MIC^2.0
            }else{
              f_MB_turn=0
            }
            
            #Equation 18
            # MAOM -> AGG
            if(MAOM>0){  
              f_MA_AG = parameters$rate_ma * scalar_wd * MAOM
            }else{
              f_MA_AG=0
            }
            
            #Equation 22
              # microbial growth flux, but is not used in mass balance
            
            #Equation 21
            # MIC -> atmosphere
            if(MIC>0){  
              f_MB_atm = f_LM_MB * (1 - (parameters$cue_ref - parameters$cue_t * (parameters$forc_st - parameters$tae_ref) ) )
            }else{
              f_MB_atm=0
            }
            
            #Equation 1
            dPOM = parameters$forc_npp * parameters$param_pi + f_AG_break * parameters$param_pa - f_PO_AG - f_PO_LM
            
            #Equation 7
            dLMWC = parameters$forc_npp * (1. - parameters$param_pi) - f_LM_leach + f_PO_LM - f_LM_MA - f_LM_MB + f_MB_turn * (1. - parameters$param_pb) + f_MA_LM
            
            #Equation 17
            dAGG = f_MA_AG + f_PO_AG - f_AG_break
      
            #Equation 20
            dMIC = f_LM_MB - f_MB_turn - f_MB_atm
            
            #Equation 19
            dMAOM = f_LM_MA - f_MA_LM + f_MB_turn * parameters$param_pb - f_MA_AG + f_AG_break * (1. - parameters$param_pa)
            
            return(list(c(dPOM, dLMWC, dAGG, dMIC, dMAOM)))
          })
        }

    # Parameters to use
    pars <- unlist(parameters.SS[[2]])
    parameters.in <- as.list(pars)

    # Define output matrix
    state.SS <- matrix(nrow=dim(inputs)[1], ncol=length(state))

#Function that solves for model steady state given the inputs at each site
    SS.Model.pools <- function(parsin, inputs) {
      for(i in 1:dim(inputs)[1]){
        tryCatch({
          parsin$forc_st <- inputs[i,1]
          parsin$forc_sw <- inputs[i,2]
          parsin$forc_npp <- inputs[i,3]
          parsin$param_qmax <- inputs[i,4]
          parsin$param_pH <- inputs[i,5]
          parsin$param_bulkd <- inputs[i,6]
          parsin$param_depth <- inputs[i,7]
          state.SS[i,] <- stode(y = state, time = SStime, func = derivs.V2.5pool.MMRMM, parms = parsin, positive=TRUE)$y
        }, error=function(e){})
      }
          modeled.pools <- as.data.frame(cbind(1:dim(inputs)[1], state.SS, rowSums(state.SS),(state.SS[,1]+state.SS[,2]+state.SS[,3]+state.SS[,4])))
          names(modeled.pools) <- c("site","POM","LMWC","AGG","MIC","MAOM","SOM","POM.AGG")
      return(modeled.pools)
    }
}
```


##Run Fit
```{r}
# Definition of the cost function
Objective.pools <- function(x, parset = names(x)) {
  pars[parset] <- x
  out <- SS.Model.pools(pars, inputs)
  modCost(out, Obs.pools, x="site", weight = "none")
}

# Calculate a sensitivity index of the C stock for each parameter using the observed input data 
if(do_sens_fun==1){
  start_time = Sys.time()
  
#Calculate the sensitivity index
  Sfun.pools <- sensFun(Objective.pools, pars)
#Plot the sensitivity index
  pdf(file=paste0(figdir,paste0("sensplot_pools_",model.name,"_",testDat,".pdf")), height=8, width=5)
  plot(summary(Sfun.pools))
  dev.off()

#Save the data
  write.csv(summary(Sfun.pools), file= paste0(figdir,model.name,"_",testDat,"_Sensplot_table.csv"))
  
  end_time = Sys.time()
  sensitivity.time <- end_time - start_time
  print(sensitivity.time)
}

#Fit the model using the Levenberg-Marquardt algorithm, described in Section 2.6.2 of Abramoff et al. (2021)
if(do_mod_fit==1){
start_time = Sys.time()

# Fit the model
Fit.pools <- modFit(
  f = Objective.pools,
  p = parToFit.pools,
  lower = parToFit.lower,
  upper = parToFit.upper,
  method = "Marq",
  jac = NULL,
  control = list(
    ftol = 1e-06,
    ptol = 1e-06,
    gtol = 1e-06,
    nprint = 1
  ),
  hessian = TRUE
)
end_time = Sys.time()
fit.time <- end_time - start_time

# Save the best parameters as a table
outtab <- cbind(Fit.pools$par, parToFit.lower, parToFit.pools, parToFit.upper)
colnames(outtab) <- c("FitPars","Lower","Default","Upper")
write.csv(outtab, file= paste0(figdir,model.name,"_",testDat,"_table.csv"))

# Recover the optimized parameters and plot the results
start_time = Sys.time()

pars[names(parToFit.pools)] <- Fit.pools$par
optim.pools <- SS.Model.pools(pars, inputs)

end_time = Sys.time()
optim.time <- end_time - start_time

ymax_plot <- ceiling(max(max(Obs.pools[, "SOM"]/1000, na.rm=T), max(optim.pools[, "SOM"]/1000, na.rm=T)))
ymax_plot <- ifelse(ymax_plot>100, 20, ymax_plot)

if(testDat == "Georgiou" & do_FME_SS_Century == 0){
pdf(file=paste0(figdir,paste0("fit_",model.name,"_",testDat,".pdf")), height=4, width=4)
par(mfrow = c(1,1))
par(mar = c(3.5,3.7,0,0)+.9)
par(oma = c(0,0,0,0))
plot(Obs.pools[, "SOM"]/1000, optim.pools[, "SOM"]/1000, xlab = expression("Observed OM (kg " ~ m^{2} ~ ")"), ylab = expression("Predicted OM (kg " ~ m^{2} ~ ")"), lwd = 2, type = "p", col = "black", ylim=c(0,ymax_plot), xlim=c(0,ymax_plot))
lines(Obs.pools[, "MAOM"]/1000, optim.pools[, "MAOM"]/1000,  lwd = 2, type = "p", col = "darkblue")
abline(0,1,lty=2)
legend("topright", c("MAOM","SOM"), col=c("darkblue","black"), pch=16)
dev.off()

}else{
  
  if(do_FME_SS_Century == 1){
  pdf(file=paste0(figdir,paste0("fit_",model.name,"_",testDat,".pdf")), height=4, width=4)
par(mfrow = c(1,1))
par(mar = c(3.5,3.7,0,0)+.9)
par(oma = c(0,0,0,0))
plot(Obs.pools[, "SOM"]/1000, optim.pools[, "SOM"]/1000, xlab = expression("Observed OM (kg " ~ m^{2} ~ ")"), ylab = expression("Predicted OM (kg " ~ m^{2} ~ ")"), lwd = 2, type = "p", col = "black", ylim=c(0,ymax_plot), xlim=c(0,ymax_plot))
  legend("topright", c("SOM"), col=c("black"), pch=16)
  abline(0,1,lty=2)
  dev.off()
  }else{
    pdf(file=paste0(figdir,paste0("fit_",model.name,"_",testDat,".pdf")), height=4, width=4)
par(mfrow = c(1,1))
par(mar = c(3.5,3.7,0,0)+.9)
par(oma = c(0,0,0,0))
plot(Obs.pools[, "SOM"]/1000, optim.pools[, "SOM"]/1000, xlab = expression("Observed OM (kg " ~ m^{2} ~ ")"), ylab = expression("Predicted OM (kg " ~ m^{2} ~ ")"), lwd = 2, type = "p", col = "black", ylim=c(0,ymax_plot), xlim=c(0,ymax_plot))
lines(Obs.pools[, "MAOM"]/1000, optim.pools[, "MAOM"]/1000,  lwd = 2, type = "p", col = "darkblue")
lines(Obs.pools[, "POM.AGG"]/1000, optim.pools[, "POM.AGG"]/1000,  lwd = 2, type = "p", col = "lightblue")
abline(0,1,lty=2)
legend("topright", c("POM & AGG","MAOM","SOM"), col=c("lightblue","darkblue","black"), pch=16)
dev.off()
  }
}

#Save observed and modeled pools
save(optim.pools, Obs.pools, testDat, file=paste0(model.name,"_",testDat,".Rdata"))

print(fit.time, optim.time)
}
```
#Cross-validation for model
```{r}
#If proptrain is less than 1, then this chunk calculates model performance indices by using the parameters fit to the training dataset to model pools which are then compared to observed pools from the testing dataset
if(proptrain != 1){

#Get best parameters
pars[names(parToFit.pools)] <- Fit.pools$par
#Calculate model pools at testing sites
optim.test <- SS.Model.pools(pars = pars, inputs = inputsTest)

#Calculate model performance indices
##Bias is modeled - observed
fit.SOM <- summary(lm(optim.test[1:dim(inputsTest)[1],]$SOM ~ obsTest$SOM))
SOM.bias <- optim.test[1:dim(inputsTest)[1],]$SOM/1000 - obsTest$SOM/1000
dim.SOM <- dim(inputsTest)[1]
RMSE_kg <- sqrt(sum((obsTest$SOM/1000- optim.test[1:dim.SOM,]$SOM/1000)^2, na.rm=T)/dim.SOM)
AIC <- dim.SOM * log(sum((obsTest$SOM/1000- optim.test[1:dim.SOM,]$SOM/1000)^2, na.rm=T)/dim.SOM) + 2*length(parameters[[3]])
MBE_SOM <- mean(SOM.bias, na.rm=T)
MAE_SOM <- mean(abs(SOM.bias), na.rm=T)
print(list(RMSE_kg = RMSE_kg,AIC = AIC, MAE_SOM = MAE_SOM, MBE_SOM = MBE_SOM, fit.SOM= fit.SOM))

fit.MAOM <- summary(lm(optim.test[1:dim(inputsTest)[1],]$MAOM ~ obsTest$MAOM))
MAOM.bias <- optim.test[1:dim(inputsTest)[1],]$MAOM/1000 - obsTest$MAOM/1000
dim.MAOM <- dim(inputsTest)[1]
MBE_MAOM <- mean(MAOM.bias, na.rm=T)
MAE_MAOM <- mean(abs(MAOM.bias), na.rm=T)
print(list(MAE_MAOM = MAE_MAOM, MBE_MAOM = MBE_MAOM, fit.MAOM= fit.MAOM))

fit.POM <- summary(lm(optim.test[1:dim(inputsTest)[1],]$POM.AGG ~ obsTest$POM.AGG))
POM.bias <- optim.test[1:dim(inputsTest)[1],]$POM.AGG/1000 - obsTest$POM.AGG/1000
dim.POM <- dim(inputsTest)[1]
MBE_POM <- mean(POM.bias, na.rm=T)
MAE_POM <- mean(abs(POM.bias), na.rm=T)
print(list(MAE_POM = MAE_POM, MBE_POM = MBE_POM, fit.POM= fit.POM))
}
```

#Model performance
##Indices for Millennial V2
```{r}
#Load data if executed separately from earlier chunks
load(paste0(model.name,"_",testDat,".Rdata"))

#Calculates model performance indices if the model is fit to the entire dataset
#Most of these except for R2 (R2in in the manuscript) are not included in Abramoff et al. (2021), but they can be interesting to explore
if(do_explore_bias == 1){
if(do_FME_SS_Century != 1){
MAOM.bias <- optim.pools[, "MAOM"]/1000 - Obs.pools[, "MAOM"]/1000
SOM.bias <- optim.pools[, "SOM"]/1000 - Obs.pools[, "SOM"]/1000
RMSE_kg <- sqrt(sum((Obs.pools[, "SOM"]/1000- optim.pools[, "SOM"]/1000)^2, na.rm=T)/dim(Obs.pools)[1])
AIC <- dim(Obs.pools)[1] * log(sum((Obs.pools[, "SOM"]/1000- optim.pools[, "SOM"]/1000)^2, na.rm=T)/dim(Obs.pools)[1]) + 2*length(parameters[[3]])

MBE_MAOM <- mean(MAOM.bias, na.rm=T)
MBE_SOM <- mean(SOM.bias, na.rm=T)
MAE_MAOM <- mean(abs(MAOM.bias), na.rm=T)
MAE_SOM <- mean(abs(SOM.bias), na.rm=T)

MAE_SOM
MBE_SOM
MAE_MAOM
MBE_MAOM
RMSE_kg
AIC

summary(lm(optim.pools[, "SOM"] ~ Obs.pools[, "SOM"]))
summary(lm(optim.pools[, "MAOM"] ~ Obs.pools[, "MAOM"]))

if(testDat != "Georgiou"){
POM.AGG.bias <- optim.pools[, "POM.AGG"]/1000 - Obs.pools[, "POM.AGG"]/1000
  
MAE_POM_AGG <- mean(abs(POM.AGG.bias), na.rm=T)
MBE_POM_AGG <- mean(POM.AGG.bias, na.rm=T)
MAE_POM_AGG
MBE_POM_AGG

summary(lm(optim.pools[, "POM.AGG"] ~ Obs.pools[, "POM.AGG"]))
}

#Organize and join dataframes for plotting SOC stocks together with environmental characteristics
if(testDat=="Georgiou"|testDat=="LUCAS"|testDat=="Viscarra-Rossel"){
datdf <- alldf[alldf$Dataset == testDat,]
}else{
datdf <- alldf
}
datdf <- datdf[!is.na(datdf$SOM),]
cordf <- datdf %>% dplyr::select(NPP.gC.m2.d, SoilMoi_m3m3, SoilTMP_C, ClaySilt, pH_CaCl2)
prep1df <- datdf %>% dplyr::select(NPP.gC.m2.d, SoilMoi_m3m3, SoilTMP_C, ClaySilt, pH_CaCl2, Biome, MAOM, SOM)

if(testDat != "Georgiou"){
prep1df <- datdf %>% dplyr::select(NPP.gC.m2.d, SoilMoi_m3m3, SoilTMP_C, ClaySilt, pH_CaCl2, Biome, POM.AGG, MAOM, SOM)
}
prep1df$Source <- rep("Observed", 1:length(dim(prep1df)[1]))
prep2df <- datdf %>% dplyr::select(NPP.gC.m2.d, SoilMoi_m3m3, SoilTMP_C, ClaySilt, pH_CaCl2, Biome)
  if(testDat != "Georgiou"){
  prep2df$POM.AGG <- optim.pools[, "POM.AGG"]
  }
prep2df$MAOM <- optim.pools[, "MAOM"]
prep2df$SOM <- optim.pools[, "SOM"]

prep2df$Source <- rep("Predicted", 1:length(dim(prep2df)[1]))

plotdf <- dplyr::full_join(prep1df, prep2df)

plot(alldf$BD, alldf$SOM.bias, xlab="Bulk Density", ylab="MAOM bias")
plot(alldf$BD_soilgrids, alldf$SOM.bias, xlab="Bulk Density Measured", ylab="Bulk Density SoilGrids")
}
}
```

##Indices for Century
```{r}
if(do_explore_bias == 1){
if(do_FME_SS_Century == 1){

#Calculates model performance indices if the model is fit to the entire dataset
#Most of these except for R2 (R2in in the manuscript) are not included in Abramoff et al. (2021), but they can be interesting to explore
SOM.bias <- optim.pools[, "SOM"]/1000 - Obs.pools[, "SOM"]/1000
 
RMSE_kg <- sqrt(sum((Obs.pools[, "SOM"]/1000- optim.pools[, "SOM"]/1000)^2)/dim(Obs.pools)[1])

#Century parameters
AIC = dim(Obs.pools)[1] * log(sum((Obs.pools[, "SOM"]/1000- optim.pools[, "SOM"]/1000)^2)/dim(Obs.pools)[1]) + 2*length(parameters[[5]])

MBE_SOM <- mean(SOM.bias)
MAE_SOM <- mean(abs(SOM.bias))
MAE_SOM
MBE_SOM
RMSE_kg
AIC

summary(lm(optim.pools[, "SOM"] ~ Obs.pools[, "SOM"]))

#Organize and join dataframes for plotting SOC stocks together with environmental characteristics
if(testDat=="Georgiou"|testDat=="LUCAS"|testDat=="Viscarra-Rossel"){
datdf <- alldf[alldf$Dataset == testDat,]
}else{
datdf <- alldf
}
datdf <- datdf[!is.na(datdf$SOM),]
cordf <- datdf %>% dplyr::select(NPP.gC.m2.d, SoilMoi_m3m3, SoilTMP_C, ClaySilt, pH_CaCl2)

prep1df <- datdf %>% dplyr::select(NPP.gC.m2.d, SoilMoi_m3m3, SoilTMP_C, ClaySilt, pH_CaCl2, Biome, SOM)
prep1df$Source <- rep("Observed", 1:length(dim(prep1df)[1]))
prep2df <- datdf %>% dplyr::select(NPP.gC.m2.d, SoilMoi_m3m3, SoilTMP_C, ClaySilt, pH_CaCl2, Biome)
prep2df$SOM <- optim.pools[, "SOM"]
prep2df$Source <- rep("Predicted", 1:length(dim(prep2df)[1]))

plotdf <- dplyr::full_join(prep1df, prep2df)
}
}
```

##Model performance by biome and NPP
```{r}
if(do_explore_bias == 1){
#Define biome names
biome.char <- as.data.frame(cbind(1:14, c("Tropical and Subtropical Moist Broadleaf Forests", "Tropical and Subtropical Dry Broadleaf Forests", "Tropical and Subtropical Coniferous Forests", "Temperate Broadleaf and Mixed Forests", "Temperate Coniferous Forests", "Boreal Forests/Taiga", "Tropical and Subtropical Grasslands, Savannas, and Shrublands", "Temperate Grasslands, Savannas, and Shrublands", "Flooded Grasslands and Savannas", "Montane Grasslands and Savannas", "Tundra", "Mediterranean Forests, Woodlands, and Scrub", "Deserts and Xeric Shrublands", "Mangroves"), c("Trop Moist BF", "Trop Dry BF", "Trop CF", "Temp BMF", "Temp CF", "Boreal F", "Trop Grass", "Temp Grasslands", "Flooded", "Montane", "Tundra", "Mediterranean", "Deserts", "Mangroves")))
names(biome.char) <- c("Biome","Biome.Description","Biome.Short")

#Define short biome names
plotdf$Biome <- as.factor(plotdf$Biome)
whole.char <- dplyr::left_join(plotdf, biome.char)
whole.char$Biome.Short <- factor(whole.char$Biome.Short,levels = c("Trop Moist BF", "Trop Dry BF", "Trop CF", "Temp BMF", "Temp CF", "Boreal F", "Trop Grass", "Temp Grasslands", "Flooded", "Montane", "Tundra", "Mediterranean", "Deserts", "Mangroves"))

#Make plots of SOC stocks and environmental characteristics by biome and NPP
##Many of these plots are exploratory and not presented in manuscript, but can be useful to see relationships between environmental characteristics
if(do_FME_SS_Century != 1){
pdf(file=paste0(figdir,"biomes_MAOM_",model.name,"_",testDat,".pdf"), height=3, width=4)
print(ggplot(whole.char, aes(x=Biome.Short, y=MAOM/1000, fill=Source)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("MAOM (kg C" ~ m^{-2} ~ ")")) +
  xlab(""))
dev.off()

pdf(file=paste0(figdir,"NPPgrad_MAOM_",model.name,"_",testDat,".pdf"), height=3, width=4)
print(ggplot(whole.char, aes(x=NPP.gC.m2.d, y=MAOM/1000, color=Source)) + geom_point(alpha = 0.3) + 
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("MAOM (kg C" ~ m^{-2} ~ ")")) +
  xlab(expression("NPP (g C" ~ m^{-2} ~ d^{-1} ~ ")")))
dev.off()

if(testDat != "Georgiou") {
pdf(file=paste0(figdir,"biomes_POM.AGG_",model.name,"_",testDat,".pdf"), height=3, width=4)
print(ggplot(whole.char, aes(x=Biome.Short, y=POM.AGG/1000, fill=Source)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("POM & AGG (kg C" ~ m^{-2} ~ ")")) +
  xlab(""))
dev.off()

pdf(file=paste0(figdir,"NPPgrad_POM.AGG_",model.name,"_",testDat,".pdf"), height=3, width=4)
print(ggplot(whole.char, aes(x=NPP.gC.m2.d, y=POM.AGG/1000, color=Source)) + geom_point(alpha = 0.3) + 
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("POM % AGG (kg C" ~ m^{-2} ~ ")")) +
  xlab(expression("NPP (g C" ~ m^{-2} ~ d^{-1} ~ ")")))
dev.off()
}
}

pdf(file=paste0(figdir,"biomes_SOM_",model.name,"_",testDat,".pdf"), height=3, width=4)
print(ggplot(whole.char, aes(x=Biome.Short, y=SOM/1000, fill=Source)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("SOM (kg C" ~ m^{-2} ~ ")")) +
  xlab(""))
dev.off()

pdf(file=paste0(figdir,"NPPgrad_SOM_",model.name,"_",testDat,".pdf"), height=3, width=4)
print(ggplot(whole.char, aes(x=NPP.gC.m2.d, y=SOM/1000, color=Source)) + geom_point(alpha = 0.3) + 
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("SOM (kg C" ~ m^{-2} ~ ")")) +
  xlab(expression("NPP (g C" ~ m^{-2} ~ d^{-1} ~ ")")))
dev.off()

pdf(file=paste0(figdir,"biomes_NPP_",testDat,".pdf"), height=3, width=4)
print(ggplot(whole.char, aes(x=Biome.Short, y=NPP.gC.m2.d)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("NPP (g C" ~ m^{-2} ~ d^{-1} ~ ")")) +
  xlab(""))
dev.off()

pdf(file=paste0(figdir,"biomes_Temp_",testDat,".pdf"), height=3, width=4)
print(ggplot(whole.char, aes(x=Biome.Short, y=SoilTMP_C)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("Soil Temperature (" ~ degree ~ "C)")) +
  xlab(""))
dev.off()

pdf(file=paste0(figdir,"biomes_Moi_",testDat,".pdf"), height=3, width=4)
print(ggplot(whole.char, aes(x=Biome.Short, y=SoilMoi_m3m3)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("VWC (" ~ m^{3} ~ m^{-3} ~ ")")) +
  xlab(""))
dev.off()

pdf(file=paste0(figdir,"biomes_Clay_",testDat,".pdf"), height=3, width=4)
print(ggplot(whole.char, aes(x=Biome.Short, y=ClaySilt)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("Clay and Silt (%)")) +
  xlab(""))
dev.off()

pdf(file=paste0(figdir,"biomes_pH_",testDat,".pdf"), height=3, width=4)
print(ggplot(whole.char, aes(x=Biome.Short, y=pH_CaCl2)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("pH")) +
  xlab(""))
dev.off()

pdf(file=paste0(figdir,"biomes_count_",testDat,".pdf"), height=3, width=4)
print(ggplot(whole.char[whole.char$Source=="Observed",], aes(x=Biome.Short)) + geom_bar(stat="count") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab("Count") +
  xlab("Biome"))
dev.off()

if(do_FME_SS_Century != 1){
if(testDat != "Georgiou"){
longdf <- plotdf %>% dplyr::rename("POM & AGG" = POM.AGG) %>%
  pivot_longer(cols="POM & AGG":SOM, names_to = "Pool", values_to = "gCm2")
pdfwidth.biomes = 6
}else{
longdf <- plotdf %>%
  pivot_longer(cols=MAOM:SOM, names_to = "Pool", values_to = "gCm2")  
pdfwidth.biomes = 4
}
pivdf <- longdf %>% 
  dplyr::group_by(Source) %>%
  dplyr::mutate(row = dplyr::row_number()) %>%
  pivot_wider(names_from = "Source", values_from = "gCm2") %>%
  dplyr::left_join(biome.char)
pivdf$Biome.Short <- factor(pivdf$Biome.Short,levels = c("Trop Moist BF", "Trop Dry BF", "Trop CF", "Temp BMF", "Temp CF", "Boreal F", "Trop Grass", "Temp Grasslands", "Flooded", "Montane", "Tundra", "Mediterranean", "Deserts", "Mangroves"))

pdf(file=paste0(figdir,"pointsbiomes_SOM_",model.name,"_",testDat,".pdf"), height=4, width=pdfwidth.biomes)
print(ggplot(pivdf, aes(x=Observed/1000, y=Predicted/1000, colour=Biome.Short, shape=Pool)) + geom_point() +
  theme(axis.text.x = element_text(angle = 90)) +
  theme_classic() +
  xlab(expression("Observed SOM (kg C" ~ m^{-2} ~ ")")) +
  ylab(expression("Predicted SOM (kg C" ~ m^{-2} ~ ")")) +
  facet_wrap(. ~ Pool, nrow=2, scales = "free") +
  labs(colour = "Biome") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed"))
dev.off()

}else{
  #Reorganize plotdf
longdf <- plotdf %>%  pivot_longer(cols=SOM, names_to = "Pool", values_to = "gCm2")
pivdf <- longdf %>% 
  dplyr::group_by(Source) %>%
  dplyr::mutate(row = row_number()) %>%
  pivot_wider(names_from = "Source", values_from = "gCm2") %>%
  dplyr::left_join(biome.char)
pivdf$Biome.Short <- factor(pivdf$Biome.Short,levels = c("Trop Moist BF", "Trop Dry BF", "Trop CF", "Temp BMF", "Temp CF", "Boreal F", "Trop Grass", "Temp Grasslands", "Flooded", "Montane", "Tundra", "Mediterranean", "Deserts", "Mangroves"))

pdf(file=paste0(figdir,"pointsbiomes_SOM_",model.name,"_",testDat,".pdf"), height=2.1, width=4)
print(ggplot(pivdf, aes(x=Observed/1000, y=Predicted/1000, colour=Biome.Short)) + geom_point(pch=15) +
  theme_classic() +
  theme(axis.text=element_text(size=10),
  axis.title=element_text(size=10)) +
  xlab(expression("Observed SOM (kg C" ~ m^{-2} ~ ")")) +
  ylab(expression("Predicted SOM (kg C" ~ m^{-2} ~ ")")) +
  labs(colour = "Biome") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed"))
dev.off()
}

}
```

##Explore model performance by land use categories in LUCAS
```{r}
#The LUCAS dataset uses particular land use categories, and while not a focus of the manuscript (although see Figure S13 for a summary figure), it can be interesting to explore the differences between predictions in different land use categories. This was initially done to see if there was a particular land use category that had much more error than the others.
if(do_explore_bias == 1){
if(testDat=="LUCAS"){
pdf(file=paste0(figdir,"LU_count_",testDat,".pdf"), height=3, width=4)
 ggplot(datdf, aes(x=LU)) + geom_bar(stat="count") +
   theme_classic() +
   theme(axis.text.x = element_text(angle = 90)) +
   ylab("Count") +
   xlab("Land Use")
 dev.off()
 
plotdf$LU <- rep(datdf$LU, 2)

#LUCAS LU categories
#C woodland: 
#C10 (Braodleaved woodland)
#C20 (Coniferous woodland)
#C30 (Mixed woodland)
#E grassland:
#E10 (Grassland with sparse tree/shrub cover)
#E20 (Grassland withouth tree/shrub cover)
#E30 (Spontaneously re-vegetated surfaces)

#Broadleaved = C10
#Mixed Forest = C30
#Coniferous = C20
#"Pure" grass = E20

#Define names for LU categories
LU.char <- as.data.frame(cbind(c("C10","C30","C20","E20","E10","E30"), c("Broadleaved","Mixed forest","Coniferous","Pure grass","Mixed grass","Re-vegetated")))
names(LU.char) <- c("LU","LU.Description")

LUdf <- dplyr::full_join(plotdf, LU.char)
LUdf$LU.Description <- factor(LUdf$LU.Description,levels = c("Pure grass","Broadleaved","Mixed forest","Coniferous","Mixed grass","Re-vegetated"))

#Plot modeled stocks for LU categories
pdf(file=paste0(figdir,"LU_MAOM_",model.name,"_",testDat,".pdf"), height=3, width=4)
print(ggplot(LUdf, aes(x=LU.Description, y=MAOM/1000, fill=Source)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("MAOM (kg C" ~ m^{-2} ~ ")")) +
  xlab(""))
dev.off()

if(testDat != "Georgiou") {
pdf(file=paste0(figdir,"LU_POM.AGG_",model.name,"_",testDat,".pdf"), height=3, width=4)
print(ggplot(LUdf, aes(x=LU.Description, y=POM.AGG/1000, fill=Source)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("POM & AGG (kg C" ~ m^{-2} ~ ")")) +
  xlab(""))
dev.off()
}

pdf(file=paste0(figdir,"LU_SOM_",model.name,"_",testDat,".pdf"), height=3, width=4)
ggplot(LUdf, aes(x=LU.Description, y=SOM/1000, fill=Source)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("SOM (kg C" ~ m^{-2} ~ ")")) +
  xlab("")
dev.off()

#Function that calculates model performance indices for LUCAS LU categories
do_LU_errors <- function(LU.Name){
SOM.bias.LU <- LUdf[LUdf$Source=="Predicted" & LUdf$LU.Description == LU.Name,]$SOM/1000 - LUdf[LUdf$Source=="Observed" & LUdf$LU.Description == LU.Name,]$SOM/1000
MBE_LU <- mean(SOM.bias.LU, na.rm=T)
MAE_LU <- mean(abs(SOM.bias.LU), na.rm=T)
LUfit <- NA

if(!all(is.na(SOM.bias.LU))){
 LUfit <- summary(lm(LUdf[LUdf$Source=="Predicted" & LUdf$LU.Description == LU.Name,]$SOM ~ LUdf[LUdf$Source=="Observed" & LUdf$LU.Description == LU.Name,]$SOM)) 
}

return(list(LUfit, MBE_LU, MAE_LU))
}

#Executes function for particular LU categories
do_LU_errors("Pure grass")
do_LU_errors("Broadleaved")
do_LU_errors("Mixed forest")
do_LU_errors("Coniferous")
do_LU_errors("Mixed grass")
}
}
```

##Plot model inputs
```{r}
#Exploratory plots that allow users to look at the relationship between different stocks and model inputs
pdf(file=paste0(figdir,"plotofinputs.pdf"), height=4, width=4)

ggplot(alldf, aes(x=NPP.gC.m2.d, y=MAOM, color=Dataset)) +
  geom_point()
ggplot(alldf, aes(x=NPP.gC.m2.d, y=POM.AGG, color=Dataset)) + geom_point()

ggplot(alldf, aes(x=SoilMoi_m3m3, y=MAOM, color=Dataset)) +
  geom_point()
ggplot(alldf, aes(x=SoilMoi_m3m3, y=POM.AGG, color=Dataset)) + geom_point()

ggplot(alldf, aes(x=SoilTMP_C, y=MAOM, color=Dataset)) +
  geom_point()
ggplot(alldf, aes(x=SoilTMP_C, y=POM.AGG, color=Dataset)) + geom_point()

ggplot(alldf, aes(x=ClaySilt, y=MAOM, color=Dataset)) +
  geom_point()
ggplot(alldf, aes(x=ClaySilt, y=POM.AGG, color=Dataset)) + geom_point()

ggplot(alldf, aes(x=pH_CaCl2, y=MAOM, color=Dataset)) +
  geom_point()
ggplot(alldf, aes(x=pH_CaCl2, y=POM.AGG, color=Dataset)) + geom_point()

dev.off()
```

#Turnover Time
##Set runtime
```{r}
#We reset the runtime, this time with a spin up
num.spin = 99
#Note: We tested different spin up cycles needed to reach steady state
#29 years is within 0.1% (0.001) of full spin-up value (SS at 100 years, same as 300)
#9 years is within 5% (0.05) of full spin-up value (but 11 years less at upper end)
end.spin = dim(inputdata)[1]*(num.spin)
run.steps <- 1:(dim(inputdata)[1]*(num.spin+1))
run.steps.minus.one <- run.steps[1:length(run.steps)-1]

#Set dynamic input functions
    forc_st <- approxfun(run.steps, rep(inputdata$forc_st,(num.spin+1)))
    forc_sw <- approxfun(run.steps, rep(inputdata$forc_sw,(num.spin+1)))
    forc_npp <- approxfun(run.steps,rep(inputdata$forc_npp,(num.spin+1)))
```

##Define dynamic models
###V2 5 pools MMRMM with respiration
```{r}
#These equations include respiration as an output, which we need to estimate a turnover time
  derivs.V2.5pool.MMRMM.resp <- function(step.num,state,parameters) {
        with(as.list(c(state,parameters)), {
          
# Soil type properties  
  #Equation 10
  kaff_lm = exp(-parameters$param_p1 * parameters$param_pH - parameters$param_p2) * parameters$kaff_des

  #Equation 11
 #param_qmax = 1 * 1000 * 0.86 * 80     
  
# Hydrological properties

  #Equation 4
  scalar_wd = (forc_sw(step.num) / parameters$porosity)^0.5

  #Equation 15
  scalar_wb = exp(parameters$lambda *-parameters$matpot) * (parameters$kamin + (1 - parameters$kamin) * ((parameters$porosity - forc_sw(step.num)) / parameters$porosity)^0.5) * scalar_wd

# Decomposition

  gas_const <- 8.31446
   
  #Equation 3
  vmax_pl = parameters$alpha_pl * exp(-parameters$eact_pl / (gas_const * (forc_st(step.num) + 273.15)))
  
  #Equation 2
    # POM -> LMWC
      if(POM>0 && MIC>0){
        f_PO_LM = POM * vmax_pl * MIC * scalar_wd / (parameters$kaff_pl + MIC)
      }else{
        f_PO_LM=0
      }
      
  #Equation 5
    # POM -> AGG
    if(POM>0){
      f_PO_AG = parameters$rate_pa * scalar_wd * POM
    }else{
      f_PO_AG=0
    }
    
  #Equation 6
    # AGG -> MAOM + POM
    if(AGG>0){
      f_AG_break = parameters$rate_break * scalar_wd * AGG
    }else{
      f_AG_break=0
    }
    
  #Equation 8
    # LMWC -> out of system leaching
    if(LMWC>0){
      f_LM_leach = parameters$rate_leach * scalar_wd * LMWC
    }else{
      f_LM_leach=0
    }
    
    #Equation 9
    # LMWC -> MAOM
    if(LMWC>0 && MAOM>0){
      f_LM_MA = scalar_wd * kaff_lm * LMWC * (1 - MAOM / parameters$param_qmax)
    }else{
      f_LM_MA=0
    }
    
  #Equation 12
    # MAOM -> LMWC
    if(MAOM>0){
      f_MA_LM = parameters$kaff_des * MAOM / parameters$param_qmax
    }else{
      f_MA_LM=0
    }
    
  #Equation 14
    vmax_lb = parameters$alpha_lb * exp(-parameters$eact_lb / (gas_const * (forc_st(step.num) + 273.15)))
  
  #Equation 13
    # LMWC -> MIC
      if(LMWC>0 && MIC>0){
        f_LM_MB = vmax_lb * scalar_wb * LMWC * MIC / (parameters$kaff_lb + LMWC)
      }else{
        f_LM_MB=0
      }
    
  #Equation 16
    # MIC -> MAOM + LMWC
    if(MIC>0){
      f_MB_turn = parameters$rate_bd * MIC^2.0
    }else{
      f_MB_turn=0
    }
    
  #Equation 18
    # MAOM -> AGG
    if(MAOM>0){  
      f_MA_AG = parameters$rate_ma * scalar_wd * MAOM
    }else{
      f_MA_AG=0
    }
    
  #Equation 22
    # microbial growth flux, but is not used in mass balance
  
  #Equation 21
    # MIC -> atmosphere
    if(MIC>0 && LMWC>0){  
    f_MB_atm = f_LM_MB * (1 - (parameters$cue_ref - parameters$cue_t * (forc_st(step.num) - parameters$tae_ref) ) )  
    }else{
      f_MB_atm=0
    }
    
  #Equation 1
    dPOM = forc_npp(step.num) * parameters$param_pi + f_AG_break * parameters$param_pa - f_PO_AG - f_PO_LM
    
  #Equation 7
    dLMWC = forc_npp(step.num) * (1. - parameters$param_pi) - f_LM_leach + f_PO_LM - f_LM_MA - f_LM_MB + f_MB_turn * (1. - parameters$param_pb) + f_MA_LM
  
  #Equation 17
    dAGG = f_MA_AG + f_PO_AG - f_AG_break
    
  #Equation 20
    dMIC = f_LM_MB - f_MB_turn - f_MB_atm
  
  #Equation 19
    dMAOM = f_LM_MA - f_MA_LM + f_MB_turn * parameters$param_pb - f_MA_AG + f_AG_break * (1. - parameters$param_pa)
  
  #Equation 23
    dOUT = f_MB_atm
    
  #Important output fluxes
    dOUTPOM = f_PO_AG + f_PO_LM
    dOUTLMWC = f_LM_leach + f_LM_MA + f_LM_MB
    dOUTAGG = f_AG_break
    dOUTMAOM = f_MA_LM + f_MA_AG 
    dOUTMIC =  f_MB_turn + f_MB_atm

              return(list(c(dPOM, dLMWC, dAGG, dMIC, dMAOM, dOUT, dOUTPOM, dOUTLMWC, dOUTAGG, dOUTMAOM, dOUTMIC)))
        })
    }

#Define initial states
    state.V2.5pool.MMRMM <- c(SS.V2.5pool.MMRMM$y, OUT = 0, OUTPOM = 0, OUTLMWC = 0, OUTAGG = 0, OUTMAOM = 0, OUTMIC = 0)

#Function that runs the model dynamically and outputs respiration and other useful output fluxes
Model.V2.5pool.MMRMM <- function (parameters, times=run.steps) {
    output <- ode(y = state.V2.5pool.MMRMM, times=run.steps, func=derivs.V2.5pool.MMRMM.resp, parms = parameters, method="rk4") #solve ode, return output
      return(as.data.frame(cbind(
      time = output[run.steps.minus.one,"time"],
      POM = output[run.steps.minus.one,"POM"], 
      LMWC = output[run.steps.minus.one,"LMWC"], 
      AGG = output[run.steps.minus.one,"AGG"], 
      MIC = output[run.steps.minus.one,"MIC"], 
      MAOM = output[run.steps.minus.one,"MAOM"], 
      OUT = diff(output[run.steps,"OUT"]), 
      OUTPOM = diff(output[run.steps,"OUTPOM"]), 
      OUTLMWC = diff(output[run.steps,"OUTLMWC"]), 
      OUTAGG = diff(output[run.steps,"OUTAGG"]), 
      OUTMIC = diff(output[run.steps,"OUTMIC"]), 
      OUTMAOM = diff(output[run.steps,"OUTMAOM"])                                 )))
}
```

####Calculate turnover time using default inputs
```{r}
#Runs the model once using default inputs
#Initialize output and define parameters
out <- NULL
pars <- parameters[[3]]

#Read in best parameters
 outtab <- read.csv(file= paste0(figdir,model.name,"_all_table.csv"))
 Fit.pools <- as.vector(outtab$FitPars)
 names(Fit.pools) <- outtab$X
 pars[names(Fit.pools)] <- Fit.pools

 #Other default inputs
    pars$param_qmax <-  1 * 1000 * 0.86 * 80  
    pars$param_pH <- 7

#Run model
start_spintime = Sys.time()
spin <- Model.V2.5pool.MMRMM(pars)
end_spintime = Sys.time()
spintime = end_spintime - start_spintime
print(spintime)
spin$SOM <- spin$POM + spin$LMWC + spin$AGG + spin$MIC + spin$MAOM

out <- spin[(end.spin+1):(length(run.steps)-1),]

#Calculate the turnover time in years
out$turnover <- out$OUT/out$SOM
summary(1/out$turnover/365)
MRT_years <- 1/out$turnover/365
```

####Calculate turnover time at each site
```{r}
#Calculate the turnover time for each site in the dataset
if(do_MRT_sites == 1){
MRT_summary <- matrix(nrow=dim(inputs)[1], ncol=6)
MRT_mean <- vector(length=dim(inputs)[1])
for (i in 1:dim(inputs)[1]){
  
#Define inputs
    forc_st <- approxfun(run.steps, rep(inputs[i,1],length(run.steps))) 
    forc_sw <- approxfun(run.steps, rep(inputs[i,2],length(run.steps)))
    forc_npp <- approxfun(run.steps,rep(inputs[i,3],length(run.steps))) 
    pars$param_qmax <- inputs[i,4]
    pars$param_pH <- inputs[i,5]
    
#Run model at each site and calculate MRT
    start_spintime = Sys.time()
spin <- Model.V2.5pool.MMRMM(pars)
end_spintime = Sys.time()
spintime = end_spintime - start_spintime
print(spintime)
spin$SOM <- spin$POM + spin$LMWC + spin$AGG + spin$MIC + spin$MAOM

out <- spin[(end.spin+1):(length(run.steps)-1),]
MRT_years <- out$SOM/out$OUT/365
MRT_summary[i,] <- summary(MRT_years)
MRT_mean[i] <- mean(MRT_years)
}

save(MRT_mean, MRT_summary, file=paste0("MRT_all.Rdata"))
}
```

##Reset runtime for Century
```{r}
#We reset the runtime with the same spin up
num.spin = 99
end.spin = dim(inputdata)[1]*(num.spin)
run.steps <- 1:(dim(inputdata)[1]*(num.spin+1))
run.steps.minus.one <- run.steps[1:length(run.steps)-1]

#Set dynamic input functions
    forc_st <- approxfun(run.steps, rep(inputdata$forc_st,(num.spin+1)))
    forc_sw <- approxfun(run.steps, rep(inputdata$forc_sw,(num.spin+1)))
    forc_npp <- approxfun(run.steps,rep(inputdata$forc_npp,(num.spin+1)))
```

###Century with respiration
```{r}
#These equations include respiration as an output, which we need to estimate a turnover time
derivs.Century.resp <- function(step.num,state,parameters) {
  with(as.list(c(state,parameters)), {

#Equation B1
  t_scalar <- (parameters$t2 + (parameters$t3 / pi) * atan(pi * parameters$t4 * (forc_st(step.num) - parameters$t1))) /
    (parameters$t2 + (parameters$t3 / pi) * atan(pi * parameters$t4 *(30.0 - parameters$t1)))

#Equation B2
  w_scalar <- 1.0 / (1.0 + parameters$w1 * exp(-parameters$w2 * forc_sw(step.num)/0.39))

#Equation B3
  f_TEX = parameters$c1 - parameters$c2*0.8
  
#Equation B4
  f_StrLitter = StrLitter * parameters$k_strlitter * t_scalar * w_scalar * exp(-3*parameters$LigFrac)
  
#Equation B5
  f_MetLitter = MetLitter * parameters$k_metlitter * t_scalar * w_scalar  
  
#Equation B6
  f_ACTIVE <- ACTIVE * parameters$k_active * t_scalar * w_scalar * f_TEX
    
#Equation B7
  f_SLOW <- SLOW * parameters$k_slow * t_scalar * w_scalar

#Equation B8
  f_PASSIVE <- PASSIVE * parameters$k_passive * t_scalar * w_scalar
  
#Equation B9
  dStrLitter = parameters$input_to_strlitter * forc_npp(step.num) - f_StrLitter
  
#Equation B10
  dMetLitter = (1-parameters$input_to_strlitter) * forc_npp(step.num) - f_MetLitter
  
#Equation B11
  dACTIVE <- (1-parameters$LigFrac) * parameters$strlitter_to_active * f_StrLitter + parameters$metlitter_to_active * f_MetLitter  + f_SLOW * parameters$slow_to_active + f_PASSIVE * parameters$passive_to_active - f_ACTIVE

#Equation B12
  dSLOW <-  parameters$LigFrac * parameters$strlitter_to_slow * f_StrLitter + f_ACTIVE * (1-f_TEX-parameters$active_to_passive) - f_SLOW
  dPASSIVE <- f_ACTIVE * parameters$active_to_passive + f_SLOW * parameters$slow_to_passive - f_PASSIVE

#Equation B13  
  dOUT <- f_ACTIVE * f_TEX + f_SLOW * (1 - parameters$slow_to_active - parameters$slow_to_passive) + f_PASSIVE * (1 - parameters$passive_to_active)
  
    return(list(c(dStrLitter, dMetLitter, dACTIVE, dSLOW, dPASSIVE, dOUT)))
  })
}

#Define initial states
state.Century = c(SS.Century$y, OUT=0)

Model.Century <- function (parameters, times=run.steps) {
    output <- ode(y = state.Century, times=run.steps, func=derivs.Century.resp, parms = parameters, method="rk4") #solve ode, return output
      return(as.data.frame(cbind(time = output[run.steps.minus.one,"time"], StrLitter = output[run.steps.minus.one,"StrLitter"], MetLitter = output[run.steps.minus.one,"MetLitter"], ACTIVE = output[run.steps.minus.one,"ACTIVE"], SLOW = output[run.steps.minus.one,"SLOW"], PASSIVE = output[run.steps.minus.one,"PASSIVE"], OUT = diff(output[run.steps,"OUT"]))))
}
```

####Caclulate turnover time using default inputs
```{r}
#Runs the model once using default inputs
#Initialize output and define parameters
out <- NULL
pars <- parameters[[5]]

#Read in best parameters
 outtab <- read.csv(file= paste0(figdir,model.name,"_all_table.csv"))
 Fit.pools <- as.vector(outtab$FitPars)
 names(Fit.pools) <- outtab$X
 pars[names(Fit.pools)] <- Fit.pools

#Run model
start_spintime = Sys.time()
spin <- Model.Century(pars)
end_spintime = Sys.time()
spintime = end_spintime - start_spintime
print(spintime)
spin$SOM <- spin$ACTIVE + spin$SLOW + spin$PASSIVE

out <- spin[(end.spin+1):(length(run.steps)-1),]

#Calculate the turnover time in years
out$turnover <- out$OUT/out$SOM
summary(1/out$turnover/365) #yr-1
MRT_years <- 1/out$turnover/365
```

####Calculate turnover time at each site
```{r}
#Calculate the turnover time for each site in the dataset
if(do_MRT_sites == 1){
MRT_summary <- matrix(nrow=dim(inputs)[1], ncol=6)
MRT_mean <- vector(length=dim(inputs)[1])
for (i in 1:dim(inputs)[1]){
  
#Define inputs
    forc_st <- approxfun(run.steps, rep(inputs[i,1],length(run.steps)))
    forc_sw <- approxfun(run.steps, rep(inputs[i,2],length(run.steps)))
    forc_npp <- approxfun(run.steps,rep(inputs[i,3],length(run.steps)))

#Run model at each site and calculate MRT
start_spintime = Sys.time()
spin <- Model.Century(pars)
end_spintime = Sys.time()
spintime = end_spintime - start_spintime
print(spintime)
spin$SOM <- spin$ACTIVE + spin$SLOW + spin$PASSIVE

out <- spin[(end.spin+1):(length(run.steps)-1),]
MRT_years <- out$SOM/out$OUT/365
MRT_summary[i,] <- summary(MRT_years)
MRT_mean[i] <- mean(MRT_years)
}

save(MRT_mean, MRT_summary, file=paste0("MRTCentury_all.Rdata"))
}
```

#Machine Learning Null Model
```{r}
if(do_explore_bias == 1){

#Prepare dataset of model inputs and observed SOM
mldfSOM.sdf <- sdf %>% dplyr::select(NPP.gC.m2.d, SoilMoi_m3m3, SoilTMP_C, ClaySilt, pH_CaCl2, SOM)
names(mldfSOM.sdf) <- c("NPP.gC.m2.d", "SoilMoi_m3m3", "SoilTMP_C", "ClaySilt", "pH_CaCl2", "Cpool")

mldfSOM.vf <- vf %>% dplyr::select(NPP.gC.m2.d, SoilMoi_m3m3, SoilTMP_C, ClaySilt, pH_CaCl2, SOM)
names(mldfSOM.vf) <- c("NPP.gC.m2.d", "SoilMoi_m3m3", "SoilTMP_C", "ClaySilt", "pH_CaCl2", "Cpool")

mldfSOM.kf <- kf %>% dplyr::select(NPP.gC.m2.d, SoilMoi_m3m3, SoilTMP_C, ClaySilt, pH_CaCl2, SOM)
names(mldfSOM.kf) <- c("NPP.gC.m2.d", "SoilMoi_m3m3", "SoilTMP_C", "ClaySilt", "pH_CaCl2", "Cpool")
mldfSOM.kf <- mldfSOM.kf[complete.cases(mldfSOM.kf), ]

mldfSOM.all <- alldf %>% dplyr::select(NPP.gC.m2.d, SoilMoi_m3m3, SoilTMP_C, ClaySilt, pH_CaCl2, SOM)
names(mldfSOM.all) <- c("NPP.gC.m2.d", "SoilMoi_m3m3", "SoilTMP_C", "ClaySilt", "pH_CaCl2", "Cpool")
mldfSOM.all <- mldfSOM.all[complete.cases(mldfSOM.all), ]

#Function that partitions data into training and testing, returning the training dataset
train_ML <- function(mldf){
set.seed(1234)
trainIndex <- createDataPartition(mldf$Cpool, p = 0.8, list = FALSE, times = 1)
mldfTrain <- mldf[trainIndex,]
mldfTest <- mldf[-trainIndex,]  
return(mldfTrain)
}

#Function that partitions data into training and testing, returning the testing dataset
test_ML <- function(mldf){
set.seed(1234)
trainIndex <- createDataPartition(mldf$Cpool, p = 0.8, list = FALSE, times = 1)
mldfTrain <- mldf[trainIndex,]
mldfTest <- mldf[-trainIndex,]  
return(mldfTest)
}

#Function that trains the machine learning model with 10-fold repeated cross-validation, using a gradient-boosting method: https://cran.r-project.org/web/packages/gbm/vignettes/gbm.pdf
do_ML <- function(mldfTrain){
fitControl <- trainControl(
  method = "repeatedcv",
  number = 10,
  repeats = 10 )
set.seed(1234)
gbmFit1 <- train( Cpool ~ ., data = mldfTrain,
                    method = "gbm",
                    trControl = fitControl,
                    verbose = FALSE )
return(gbmFit1)
}

#Summarizes model perfomrance for the ML models
TrainSOM.sdf <- train_ML(mldfSOM.sdf)
gbmSOM.sdf <- do_ML(TrainSOM.sdf)
summary(lm(TrainSOM.sdf$Cpool~predict(gbmSOM.sdf)))
TestSOM.sdf <- test_ML(mldfSOM.sdf)
gbmSOM.sdf
summary(gbmSOM.sdf)

TrainSOM.vf <- train_ML(mldfSOM.vf)
gbmSOM.vf <- do_ML(TrainSOM.vf)
summary(lm(TrainSOM.vf$Cpool~predict(gbmSOM.vf)))
TestSOM.vf <- test_ML(mldfSOM.vf)
gbmSOM.vf
summary(gbmSOM.vf)

TrainSOM.kf <- train_ML(mldfSOM.kf)
gbmSOM.kf <- do_ML(TrainSOM.kf)
summary(lm(TrainSOM.kf$Cpool~predict(gbmSOM.kf)))
TestSOM.kf <- test_ML(mldfSOM.kf)
gbmSOM.kf
summary(gbmSOM.kf)

TrainSOM.all <- train_ML(mldfSOM.all)
gbmSOM.all <- do_ML(TrainSOM.all)
summary(lm(TrainSOM.all$Cpool~predict(gbmSOM.all)))
TestSOM.all <- test_ML(mldfSOM.all)
gbmSOM.all
summary(gbmSOM.all)

#Partition just the input data
sdfselect <- mldfSOM.sdf[,c("NPP.gC.m2.d", "SoilMoi_m3m3", "SoilTMP_C", "ClaySilt", "pH_CaCl2")]
vfselect <- mldfSOM.vf[,c("NPP.gC.m2.d", "SoilMoi_m3m3", "SoilTMP_C", "ClaySilt", "pH_CaCl2")]
kfselect <- mldfSOM.kf[,c("NPP.gC.m2.d", "SoilMoi_m3m3", "SoilTMP_C", "ClaySilt", "pH_CaCl2")]

#Test if null models can predict other datasets
summary(lm(mldfSOM.sdf$Cpool~predict(gbmSOM.vf, newdata = sdfselect)))
summary(lm(mldfSOM.kf$Cpool~predict(gbmSOM.vf, newdata = kfselect))) 
summary(lm(mldfSOM.vf$Cpool~predict(gbmSOM.sdf, newdata = vfselect))) 
summary(lm(mldfSOM.kf$Cpool~predict(gbmSOM.sdf, newdata = kfselect))) 
summary(lm(mldfSOM.sdf$Cpool~predict(gbmSOM.kf, newdata = sdfselect)))
summary(lm(mldfSOM.vf$Cpool~predict(gbmSOM.kf, newdata = vfselect)))

#Plot model performance - training dataset - Figure S11 in Abramoff et al. (2021)
ymax_plot <- 30
ylab.ml <- expression("Predicted C stock (kg C " ~ m^{2} ~ ")")
xlab.ml <- expression("Observed C stock (kg C " ~ m^{2} ~ ")")
pdf(file=paste0(figdir,paste0("FigureS11.pdf")), height=5, width=5)
par(mfrow = c(2,2))
par(mar = c(3.5,3.7,0,0.1)+.9)
par(oma = c(0,0,0,0))
plot(TrainSOM.all$Cpool/1000, predict(gbmSOM.all)/1000, xlab = xlab.ml, ylab = ylab.ml, lwd = 2, type = "p", col = cbPalette[1], ylim=c(0,ymax_plot), xlim=c(0,ymax_plot), main="All")
abline(0,1,lty=2)

plot(TrainSOM.vf$Cpool/1000, predict(gbmSOM.vf)/1000, xlab = xlab.ml, ylab = ylab.ml, lwd = 2, type = "p", col = cbPalette[2], ylim=c(0,ymax_plot), xlim=c(0,ymax_plot), main="Viscarra Rossel")
abline(0,1,lty=2)

plot(TrainSOM.kf$Cpool/1000, predict(gbmSOM.kf)/1000, xlab = xlab.ml, ylab = ylab.ml, lwd = 2, type = "p", col = cbPalette[6], ylim=c(0,ymax_plot), xlim=c(0,ymax_plot), main="Georgiou")
abline(0,1,lty=2)

plot(TrainSOM.sdf$Cpool/1000, predict(gbmSOM.sdf)/1000, xlab = xlab.ml, ylab = ylab.ml, lwd = 2, type = "p", col = cbPalette[7], ylim=c(0,ymax_plot), xlim=c(0,ymax_plot), main="LUCAS")
abline(0,1,lty=2)
dev.off()

#Plot model performance - testing dataset - Figure S12 in Abramoff et al. (2021)
pdf(file=paste0(figdir,paste0("FigureS12.pdf")), height=5, width=5)
par(mfrow = c(2,2))
par(mar = c(3.5,3.7,0,0.1)+.9)
par(oma = c(0,0,0,0))
plot(TestSOM.all$Cpool/1000, predict(gbmSOM.all, newdata=TestSOM.all)/1000, xlab = xlab.ml, ylab = ylab.ml, lwd = 2, type = "p", col = cbPalette[1], ylim=c(0,ymax_plot), xlim=c(0,ymax_plot), main="All")
abline(0,1,lty=2)

plot(TestSOM.vf$Cpool/1000, predict(gbmSOM.vf, newdata=TestSOM.vf)/1000, xlab = xlab.ml, ylab = ylab.ml, lwd = 2, type = "p", col = cbPalette[2], ylim=c(0,ymax_plot), xlim=c(0,ymax_plot), main="Viscarra Rossel")
abline(0,1,lty=2)

plot(TestSOM.kf$Cpool/1000, predict(gbmSOM.kf, newdata=TestSOM.kf)/1000, xlab = xlab.ml, ylab = ylab.ml, lwd = 2, type = "p", col = cbPalette[6], ylim=c(0,ymax_plot), xlim=c(0,ymax_plot), main="Georgiou")
abline(0,1,lty=2)

plot(TestSOM.sdf$Cpool/1000, predict(gbmSOM.sdf, newdata=TestSOM.sdf)/1000, xlab = xlab.ml, ylab = ylab.ml, lwd = 2, type = "p", col = cbPalette[7], ylim=c(0,ymax_plot), xlim=c(0,ymax_plot), main="LUCAS")
abline(0,1,lty=2)
dev.off()

pdf(file=paste0(figdir,paste0("FigureS_VARIMPALL.pdf")), height=5, width=5)
summary(gbmSOM.all)
dev.off()
}
```

#Testing whether Millennial V2 can predict one dataset when fit to another
```{r}
#Load fitted parameters for current dataset (chosen using testDat in Switches)
load(file=paste0(codedir,"V2.5pool.MMRMM_",testDat,".Rdata"))

outtab <- read.csv(file= paste0(figdir,"V2.5pool.MMRMM_",testDat,"_table.csv"))
Fit.pools <- as.vector(outtab$FitPars)
names(Fit.pools) <- outtab$X

pars <- parameters[[3]]
pars[names(Fit.pools)] <- Fit.pools

#Organize inputs
inputs.all <- cbind(alldf$SoilTMP_C, alldf$SoilMoi_m3m3, alldf$NPP.gC.m2.d, alldf$qmax.gC.m2, alldf$pH_CaCl2, alldf$BD_all*1000,alldf$depth_all)
inputs.all <- inputs.all[!is.na(alldf$SOM),]

#Define initial states and parameters
    state <- c(POM = 1, LMWC = 1, AGG = 1, MIC = 1, MAOM=1)
    state.SS <- matrix(nrow=dim(inputs.all)[1], ncol=5)
    parameters.in <- as.list(pars)
    
#Defines function that runs the model at all sites using the fitted parameters for the currently loaded dataset
    SS.Model.pools.all <- function(parsin, inputs) {
      for(i in 1:dim(inputs)[1]){
        tryCatch({
          parsin$forc_st <- inputs[i,1]
          parsin$forc_sw <- inputs[i,2]
          parsin$forc_npp <- inputs[i,3]
          parsin$param_qmax <- inputs[i,4]
          parsin$param_pH <- inputs[i,5]
          parsin$param_bulkd <- inputs[i,6]
          parsin$param_depth <- inputs[i,7]
          state.SS[i,] <- stode(y = state, time = SStime, func = derivs.V2.5pool.MMRMM, parms = parsin, positive=TRUE)$y
        }, error=function(e){})
      }
          modeled.pools <- as.data.frame(cbind(1:dim(inputs)[1], state.SS, rowSums(state.SS),(state.SS[,1]+state.SS[,2]+state.SS[,3]+state.SS[,4])))
          names(modeled.pools) <- c("site","POM","LMWC","AGG","MIC","MAOM","SOM","POM.AGG")
      return(modeled.pools)
    }

#Executes function
optim.all <- SS.Model.pools.all(parameters.in, inputs.all)
names(optim.all) <- c("site","POM.optim","LMWC.optim","AGG.optim","MIC.optim","MAOM.optim","SOM.optim","POM.AGG.optim")

#Organizes output
alldf.all <- alldf[!is.na(alldf$SOM),]
best.all <- cbind(optim.all, alldf.all)

#Calculates whether the model fitted using testDat data can predict the other datasets well
testDats <- c("Viscarra-Rossel", "Georgiou", "LUCAS")
for (i in 1:length(testDats)){
dim.SOM <- dim(best.all[best.all$Dataset==testDats[i],])[1]
Obs.SOM <- best.all[best.all$Dataset==testDats[i],]$SOM
optim.SOM <- best.all[best.all$Dataset==testDats[i],]$SOM.optim
fit.SOM <- summary(lm(Obs.SOM ~ optim.SOM))
SOM.bias <- optim.SOM/1000 - Obs.SOM/1000
RMSE_kg <- sqrt(sum((Obs.SOM/1000- optim.SOM/1000)^2, na.rm=T)/dim(Obs.pools)[1])
AIC <- dim.SOM * log(sum((Obs.SOM/1000- optim.SOM/1000)^2, na.rm=T)/dim.SOM) + 2*length(parameters[[3]])
MBE_SOM <- mean(SOM.bias, na.rm=T)
MAE_SOM <- mean(abs(SOM.bias), na.rm=T)
print(list(RMSE_kg = RMSE_kg,AIC = AIC, MAE_SOM = MAE_SOM, MBE_SOM = MBE_SOM, fit.SOM= fit.SOM))
}
```

#Figures and analyses using all datasets together
##Load model fits and do data prep
```{r}
model.names <- c("V2.5pool.MMRMM","Century")
testDats <- c("all","Viscarra-Rossel","Georgiou","LUCAS")

#Load and organize dataframes
results.df <- NULL
temp.df <- NULL
for(i in 1:length(model.names)){
 for(j in 1:length(testDats)){
  if (i==1 & j==1){
    load(file=paste0(model.names[1],"_",testDats[1],".Rdata"))
    optim.pools$site <- Obs.pools$site
    results.df <- as.data.frame(cbind(optim.pools, Source="Optimized"))
    results.df <- results.df %>% dplyr::full_join(cbind(Obs.pools, Source="Observed")) %>% tibble::add_column(Dataset = testDats[1], Model = model.names[1])
  }else{
    load(file=paste0(model.names[i],"_",testDats[j],".Rdata"))
    optim.pools$site <- Obs.pools$site
    temp.df <- as.data.frame(cbind(optim.pools, Source="Optimized"))
    temp.df <- temp.df %>% dplyr::full_join(cbind(Obs.pools, Source="Observed")) %>% tibble::add_column(Dataset = testDats[j], Model = model.names[i])
    results.df <- results.df %>% dplyr::full_join(temp.df)
  }
 }
}

#Convert units of SOC pools
results.df <- results.df %>% dplyr::mutate(POM_kg = POM/1000, LMWC_kg = LMWC/1000, AGG_kg = AGG/1000, MIC_kg = MIC/1000, MAOM_kg = MAOM/1000, SOM_kg = SOM/1000, POM.AGG_kg = POM.AGG/1000, StrLitter_kg = StrLitter/1000, MetLitter_kg = MetLitter/1000, ACTIVE_kg = ACTIVE/1000, SLOW_kg = SLOW/1000, PASSIVE_kg = PASSIVE/1000) %>% dplyr::select(-c(POM:POM.AGG,StrLitter:PASSIVE))

#Recalculating POM.AGG - identical values for VR and LUCAS datasets, but now estimates POM.AGG for the KG dataset by subtraction
results.df$POM.AGG_kg <- results.df$SOM_kg - results.df$MAOM_kg

#Organize columns for easier plotting with ggplot
plot.df <- results.df %>% tidyr::pivot_longer(POM_kg:PASSIVE_kg, names_to="Pool", values_to = "C_pool") %>% dplyr::select(c( "site", "Source", "Dataset", "Model", "Pool", "C_pool")) %>%  tidyr::pivot_wider(names_from="Source", values_from ="C_pool")
plot.df$Dataset <- factor(plot.df$Dataset, levels=c("all","Viscarra-Rossel","Georgiou","LUCAS"), labels=c("All","Viscarra Rossel","Georgiou","LUCAS")) 

#Add facet label names for plotting
model.labs <- c("Century", "Millennial V2") 
names(model.labs) <- c("Century", "V2.5pool.MMRMM")

source.labs <- c("Observed", "Century", "Millennial V2") 
names(source.labs) <- c("Observed", "Century", "V2.5pool.MMRMM")

#Dataframe for plotting SOM fractions
plot.som.df <- plot.df[plot.df$Pool == "SOM_kg" | plot.df$Pool == "MAOM_kg",]

#Dataframe for plotting SOM by biome categories
biome.char <- as.data.frame(cbind(1:14, c("Tropical and Subtropical Moist Broadleaf Forests", "Tropical and Subtropical Dry Broadleaf Forests", "Tropical and Subtropical Coniferous Forests", "Temperate Broadleaf and Mixed Forests", "Temperate Coniferous Forests", "Boreal Forests/Taiga", "Tropical and Subtropical Grasslands, Savannas, and Shrublands", "Temperate Grasslands, Savannas, and Shrublands", "Flooded Grasslands and Savannas", "Montane Grasslands and Savannas", "Tundra", "Mediterranean Forests, Woodlands, and Scrub", "Deserts and Xeric Shrublands", "Mangroves"), c("Trop Moist BF", "Trop Dry BF", "Trop CF", "Temp BMF", "Temp CF", "Boreal F", "Trop Grass", "Temp Grasslands", "Flooded", "Montane", "Tundra", "Mediterranean", "Deserts", "Mangroves")))
names(biome.char) <- c("Biome","Biome.Description","Biome.Short")
alldf$Biome <- as.factor(alldf$Biome)
longdf1 <- alldf
longdf2 <- longdf1
longdf2$Dataset <- rep("all")
fulldf <- rbind(longdf1, longdf2)
fulldf$site <- c(1:dim(fulldf[fulldf$Dataset=="Viscarra-Rossel",])[1], 1:dim(fulldf[fulldf$Dataset=="LUCAS",])[1], 1:dim(fulldf[fulldf$Dataset=="Georgiou",])[1], 1:dim(fulldf[fulldf$Dataset=="all",])[1])

#Prepare LUCAS land use type labels
LU.char <- as.data.frame(cbind(c("C10","C30","C20","E20","E10","E30"), c("Broadleaved","Mixed forest","Coniferous","Pure grass","Mixed grass","Re-vegetated")))
names(LU.char) <- c("LU","LU.Description")

#Create a new column called Source that identifies values as either Observed, modeled by Century, or modeled by Millennial V2, for plotting
results.df[results.df$Source == "Optimized",]$Source <- results.df[results.df$Source == "Optimized",]$Model
results.df$Source <- factor(results.df$Source, levels = c("Observed", "Century", "V2.5pool.MMRMM"))
results.df <- results.df[!(results.df$Source == "Observed" & results.df$Model == "Century"),]

#Organize data frames with biome and LU labels
plot.all <- fulldf %>% dplyr::left_join(biome.char, by="Biome") %>% dplyr::full_join(results.df) %>% dplyr::left_join(LU.char)
plot.all$Biome.Short <- factor(plot.all$Biome.Short, levels = c("Boreal F", "Temp CF", "Temp BMF", "Montane", "Temp Grasslands", "Mediterranean", "Deserts", "Trop Moist BF", "Trop Grass", "Flooded", "Tundra", "Mangroves", "Trop Dry BF", "Trop CF"))
plot.all$LU.Description <- factor(plot.all$LU.Description,levels = c("Pure grass","Broadleaved","Mixed forest","Coniferous","Mixed grass","Re-vegetated"))

plot.all$Dataset <- factor(plot.all$Dataset, levels=c("all","Viscarra-Rossel","Georgiou","LUCAS"), labels=c("All","Viscarra Rossel","Georgiou","LUCAS"))

plot.fractions.df <- plot.all %>% dplyr::select(c( "site", "Source", "Dataset", "MAOM_kg", "POM.AGG_kg", "Biome.Short")) %>% tidyr::pivot_longer(MAOM_kg:POM.AGG_kg, names_to="Pool", values_to = "C_pool") 

plot.LU.df <- plot.all %>% dplyr::select(c( "site", "Source", "Dataset", "SOM_kg", "MAOM_kg", "POM.AGG_kg","LU.Description")) %>% tidyr::pivot_longer(SOM_kg:POM.AGG_kg, names_to="Pool", values_to = "C_pool") 
pool.labs <- c("MAOM", "Non-MAOM", "SOC") 
names(pool.labs) <- c("MAOM_kg", "POM.AGG_kg", "SOM_kg")
```

##Make model fit and biome plots
```{r}
max.som <- 30
#Plot model fit to data - Figure 4 in Abramoff et al (2021)
pdf(file=paste0(figdir,"Figure4.pdf"), height=2.75, width=6)
ggplot(plot.som.df, aes(x = Observed, y = Optimized, col = Pool)) +
  geom_point(alpha = 0.5, size = 0.5) +
  geom_abline(slope=1, intercept=0, linetype = "dashed") +
  xlim(0,max.som) + ylim(0,max.som) +
  facet_grid(Model ~ Dataset, labeller = labeller(Model = model.labs)) +
  xlab(expression("Modeled C stock (kgC " ~ m^{-2} ~ ")")) +
  ylab(expression("Observed C stock (kgC " ~ m^{-2} ~ ")")) +
  theme_classic() +
  scale_color_manual(values = c(cbPalette[2], cbPalette[4]), name="Pool", labels =c("MAOM","SOC")) + guides(colour = guide_legend(override.aes = list(size=5)))
dev.off()

#Divide dataframe to either include all data or each dataset separately
plot.all.all <- plot.all[plot.all$Dataset == "All",]
plot.all.dats <- plot.all[plot.all$Dataset != "All",]

#Plot SOM in each biome category - Figure 7 in Abramoff et al. (2021)
pdf(file=paste0(figdir,"Figure7.pdf"), height=4, width=5.5)
ggplot(plot.all.all, aes(x=Biome.Short, y=SOM_kg, fill=Source)) + geom_boxplot() +
  scale_fill_manual(values = c(cbPalette[3], cbPalette[5], cbPalette[6]), name="", labels =c("Observed","Century","Millennial V2")) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("C stock (kg C" ~ m^{-2} ~ ")")) +
  xlab("") + stat_n_text(size = 2)
dev.off()

#Plot SOM in each biome category - Figure S8 in Abramoff et al. (2021)
pdf(file=paste0(figdir,"FigureS8.pdf"), height=5, width=8)
ggplot(plot.all.dats, aes(x=Biome.Short, y=SOM_kg, fill=Source)) + geom_boxplot() +
  facet_wrap(~Dataset, nrow=2) +
  scale_fill_manual(values = c(cbPalette[3], cbPalette[5], cbPalette[6]), name="", labels =c("Observed","Century","Millennial V2")) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("C stock (kg C" ~ m^{-2} ~ ")")) +
  xlab("") + stat_n_text(size = 2)
dev.off()

#Divide dataframe to either include all data or each dataset separately
plot.fractions.df.all <- plot.fractions.df[plot.fractions.df$Dataset == "All",]
plot.fractions.df.dats <- plot.fractions.df[plot.fractions.df$Dataset != "All",]

#Plot C in each fraction by biome - Figure 8 in Abramoff et al. (2021)
pdf(file=paste0(figdir,"Figure8.pdf"), height=5, width=5.5)
ggplot(plot.fractions.df.all, aes(x=Biome.Short, y=C_pool, fill=Source)) + geom_boxplot() +
  facet_grid(Pool ~ ., labeller = labeller(Pool = pool.labs), scales="free") +
  scale_fill_manual(values = c(cbPalette[3], cbPalette[6]), name="", labels =c("Observed","Millennial V2")) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("C stock (kg C" ~ m^{-2} ~ ")")) +
  xlab("")
dev.off()

#Plot C in each fraction by biome - Figure S9 in Abramoff et al. (2021)
pdf(file=paste0(figdir,"FigureS9.pdf"), height=5, width=11)
ggplot(plot.fractions.df.dats, aes(x=Biome.Short, y=C_pool, fill=Source)) + geom_boxplot() +
  facet_grid(Pool ~ Dataset, labeller = labeller(Pool = pool.labs), scales="free") +
  scale_fill_manual(values = c(cbPalette[3], cbPalette[6]), name="", labels =c("Observed","Millennial V2")) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("C stock (kg C" ~ m^{-2} ~ ")")) +
  xlab("")
dev.off()

plot.LUCAS <- plot.LU.df[plot.LU.df$Dataset=="LUCAS" & !is.na(plot.LU.df$LU.Description),]

#Plot C by LU in LUCAS - Figure S13 in Abramoff et al. (2021)
pdf(file=paste0(figdir,"FigureS13.pdf"), height=5, width=6)
ggplot(plot.LUCAS, aes(x=LU.Description, y=C_pool, fill=Source)) + geom_boxplot() +
  facet_wrap(~Pool, scales="free", labeller = labeller(Pool = pool.labs), nrow = 2) +
  scale_fill_manual(values = c(cbPalette[3], cbPalette[5], cbPalette[6]), name="", labels =c("Observed","Century","Millennial V2")) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("C stock (kg C" ~ m^{-2} ~ ")")) +
  xlab("")
dev.off()

#Plot relationship between SOC and NPP - Figure 10 in Abramoff et al. (2021)
plot.npp <- plot.all[!is.na(plot.all$Source),]
pdf(file=paste0(figdir,"FigureS10.pdf"), height=4, width=6)
ggplot(plot.npp, aes(x = NPP.gC.m2.d, y = SOM_kg)) +
  geom_point(alpha = 0.5, size = 0.5) +
  facet_grid(Source ~ Dataset, labeller = labeller(Source = source.labs)) +
  ylab(expression("C stock (kgC " ~ m^{-2} ~ ")")) +
  xlab(expression("NPP (g C " ~ m^{-2} ~ d^{-1} ~")")) +
  theme_classic() + guides(colour = guide_legend(override.aes = list(size=5)))
dev.off()

#Make boxplots of bias for biome plots
plot.all.bias <- plot.all %>% dplyr::select(c("site", "Source", "Dataset", "SOM_kg", "Biome.Short")) %>% tidyr::pivot_wider(names_from="Source", values_from ="SOM_kg") %>% 
  dplyr::mutate(Century_bias = Observed-Century, V2_bias = Observed-V2.5pool.MMRMM) %>%
dplyr::select(c("site", "Dataset","Century_bias", "V2_bias", "Biome.Short")) %>%
  tidyr::pivot_longer(Century_bias:V2_bias, names_to = "Model_Bias")
  
#Model bias by biome - Figure S6 in Abramoff et al. (2021)
pdf(file=paste0(figdir,"FigureS6.pdf"), height=6, width=8)
ggplot(plot.all.bias, aes(x=Biome.Short, y=value, fill=Model_Bias)) + geom_boxplot() +
  facet_wrap(~Dataset, nrow=2) +
  scale_fill_manual(values = c(cbPalette[5], cbPalette[6]), name="", labels =c("Century","Millennial V2")) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("C stock bias (kg C" ~ m^{-2} ~ ")")) +
  xlab("") + stat_n_text(size = 2) +
  geom_hline(yintercept = 0, linetype='dotted')
dev.off()

plot.fractions.bias <- plot.fractions.df %>% tidyr::pivot_wider(names_from="Source", values_from ="C_pool") %>% 
  dplyr::mutate(V2_bias = Observed-V2.5pool.MMRMM) 

#Model bias for each fraction by biome - Figure S7 in Abramoff et al. (2021)
pdf(file=paste0(figdir,"FigureS7.pdf"), height=6, width=8)
ggplot(plot.fractions.bias, aes(x=Biome.Short, y=V2_bias, fill=Pool)) + geom_boxplot() +
  facet_wrap(~Dataset, nrow=2) +
  scale_fill_manual(values = c("#999999",cbPalette[8]), name="", labels =c("MAOM","Non-MAOM")) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("C stock bias (kg C" ~ m^{-2} ~ ")")) +
  xlab("") +
  geom_hline(yintercept = 0, linetype='dotted')
dev.off()
```

##Make latitude plots
```{r}
plot.lat <- plot.all %>% tidyr::pivot_longer(POM_kg:PASSIVE_kg, names_to="Pool", values_to = "C_pool") %>% dplyr::select(c( "site", "Source", "Dataset", "Model", "Pool", "C_pool","GPS_LONG","GPS_LAT"))
plot.lat$Dataset <- factor(plot.lat$Dataset, levels=c("all","Viscarra Rossel","Georgiou","LUCAS"), labels=c("All","Viscarra Rossel","Georgiou","LUCAS")) 

#Make latitude bins for SOM
 bin.plot <- plot.lat %>% 
   dplyr::filter(Pool == "SOM_kg") %>%
   dplyr::mutate(GPS_Bin = round(GPS_LAT, -1)) %>%
   dplyr::filter(!is.na(C_pool)) %>%
   dplyr::mutate(GPS_Bin=factor(GPS_Bin, levels=seq(-50,70, by=10)))
 
 bin.plot.pools <- plot.lat %>% 
   dplyr::mutate(GPS_Bin = round(GPS_LAT, -1)) %>%
   dplyr::filter(!is.na(C_pool)) %>%
   dplyr::mutate(GPS_Bin=factor(GPS_Bin, levels=seq(-50,70, by=10)))
 
#Make latitude bin labels
makelabelsNS <- function(x) {ifelse(x < 0, parse(text=paste0(x,"^o", "*S")), ifelse(x > 0, parse(text=paste0(x,"^o", "*N")),x))}

ybreaks <- seq(-50,70,10)
ylabels <- makelabelsNS(ybreaks) 

#Plot SOM by latitude
pdf(file=paste0(figdir,"Figure_LAT.pdf"), height=3.5, width=5)
print(ggplot(data = bin.plot, aes(y=C_pool, x = GPS_Bin, fill=Source))+
  geom_boxplot() + 
  facet_grid(~Source, labeller = labeller(Source = source.labs)) +
  scale_fill_manual(values = c(cbPalette[3], cbPalette[5], cbPalette[6]), name="", labels =c("Observed","Century","Millennial V2")) +
  theme_classic() +
    theme(legend.position = "none") +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("C stock (kg C " ~ m^{2} ~ ")")) +
  scale_x_discrete(name = "Latitude", breaks = ybreaks, drop=FALSE, labels = ylabels) +
  coord_flip())
dev.off()

#Plot SOM by latitude - Figure 5 in Abramoff et al. (2021)
pdf(file=paste0(figdir,"Figure5.pdf"), height=3.5, width=5)
print(ggplot(data = bin.plot, aes(y=C_pool, x = GPS_Bin, fill=Source))+
  geom_boxplot() + 
  scale_fill_manual(values = c(cbPalette[3], cbPalette[5], cbPalette[6]), name="", labels =c("Observed","Century","Millennial V2")) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0)) +
  ylab(expression("C stock (kg C " ~ m^{2} ~ ")")) +
  scale_x_discrete(name = "Latitude", breaks = ybreaks, drop=FALSE, labels = ylabels) +
  coord_flip())
dev.off()
```

##Make latitude bias plot
```{r}
#Make plots of bias by latitude
plot.lat.bias <- plot.all %>%
  tidyr::pivot_longer(POM_kg:PASSIVE_kg, names_to="Pool", values_to = "C_pool") %>% dplyr::select(c( "site", "Source", "Dataset", "Pool", "C_pool","GPS_LONG","GPS_LAT")) %>%  
   dplyr::filter(Pool == "SOM_kg") %>%
   tidyr::pivot_wider(names_from="Source", values_from ="C_pool") %>%
  dplyr::mutate(Century_bias = Observed-Century, V2_bias = Observed-V2.5pool.MMRMM) %>%
  tidyr::pivot_longer(Century_bias:V2_bias, names_to = "Model_Bias")

#Make latitude bins for bias
  bin.plot.bias <- plot.lat.bias %>% 
   dplyr::mutate(GPS_Bin = round(GPS_LAT, -1)) %>%
   dplyr::filter(!is.na(value)) %>%
   dplyr::mutate(GPS_Bin=factor(GPS_Bin, levels=seq(-50,70, by=10)))
 
bias.labs <- c("Millennial V2",  "Century") 
names(bias.labs) <- c("V2_bias", "Century_bias")

#Plot bias by latitude - Figure S5 in Abramoff et al. (2021)
pdf(file=paste0(figdir,"FigureS5.pdf"), height=3.5, width=5)
print(ggplot(data = bin.plot.bias, aes(y=value, x = GPS_Bin, fill=Model_Bias))+
  geom_boxplot() + 
  facet_grid(~Model_Bias, labeller = labeller(Model_Bias = bias.labs)) +
  scale_fill_manual(values = c(cbPalette[5], cbPalette[6]), name="", labels =c("Century","Millennial V2")) +
  theme_classic() +
    theme(legend.position = "none") +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("C stock bias (kg C " ~ m^{2} ~ ")")) +
  scale_x_discrete(name = "Latitude", breaks = ybreaks, drop=FALSE, labels = ylabels) +
    geom_hline(yintercept = 0, linetype='dotted') +
  coord_flip())
dev.off()
```

##Make stacked bar chart of model pools
```{r}
#Organize model pools for stacked plotting
pie.plot <- bin.plot.pools %>%
  dplyr::filter(Pool != "SOM_kg") %>%
  dplyr::filter(!(Source=="V2.5pool.MMRMM"&Pool=="POM.AGG_kg")) %>%
  dplyr::group_by(Pool, GPS_Bin, Source) %>%
  dplyr::summarise( median=median(C_pool, na.rm=T), se=sd(C_pool, na.rm=T)/dplyr::n(), n=dplyr::n())

summary.pie.plot <- bin.plot.pools %>%
  dplyr::filter(Pool != "SOM_kg") %>%
  dplyr::filter(!(Source=="V2.5pool.MMRMM"&Pool=="POM.AGG_kg")) %>%
  dplyr::group_by(Pool, Source) %>%
  dplyr::summarise( median=median(C_pool, na.rm=T), se=sd(C_pool, na.rm=T)/dplyr::n(), n=dplyr::n())

pie.plot$Pool <- factor(pie.plot$Pool, levels=c("MIC_kg","LMWC_kg","POM_kg","AGG_kg","MetLitter_kg","StrLitter_kg","ACTIVE_kg","SLOW_kg","PASSIVE_kg","POM.AGG_kg","MAOM_kg"), labels=c("MIC","LMWC","POM","AGG","MetLitter","StrLitter","ACTIVE","SLOW","PASSIVE","non-MAOM","MAOM"))

summary.pie.plot

#Summarize fraction of C in each pool for Millennial model
load(file=paste0("V2.5pool.MMRMM_all.Rdata"))
summary(optim.pools$MAOM/optim.pools$SOM)
summary(optim.pools$POM/optim.pools$SOM)
summary(optim.pools$AGG/optim.pools$SOM)
summary(optim.pools$MIC/optim.pools$SOM)
summary(optim.pools$LMWC/optim.pools$SOM)

this <- results.df[results.df$Source=="V2.5pool.MMRMM" & results.df$Dataset=="all",]
summary(this$MAOM_kg/this$SOM_kg)
that <- results.df[results.df$Source=="Century" & results.df$Dataset=="all",]
summary(that$SLOW_kg/that$SOM_kg)
theother <- results.df[results.df$Source=="Observed" & results.df$Dataset=="all",]
summary(theother$MAOM_kg/theother$SOM_kg)

#Summarize observed fraction MAOM
observedfracMAOM <- c( kf$MAOM/kf$SOM , vf$hocd030.gC.m2/(vf$pocd030.gC.m2+vf$hocd030.gC.m2) , sdf$MAOM/(sdf$MAOM + sdf$POM.AGG) )
summary(observedfracMAOM)

#Summarize fraction of C in each pool for Century model 
load(file=paste0("Century_all.Rdata"))
summary(optim.pools$ACTIVE/optim.pools$SOM)
summary(optim.pools$SLOW/optim.pools$SOM)
summary(optim.pools$PASSIVE/optim.pools$SOM)

#Plot amount of C in each pool by latitude - Figure 6 in Abramoff et al. (2021)
pdf(file=paste0(figdir,"Figure6.pdf"), height=3.5, width=7)
print(ggplot(data = pie.plot, aes(y=median, x = GPS_Bin, fill=Pool))+
  geom_bar(stat="identity") + 
  facet_grid(~Source, labeller = labeller(Source = source.labs)) +
  scale_fill_manual(values = c(cbPalette[1], cbPalette[2], cbPalette[3],cbPalette[4],"blueviolet",cbPalette[5],"darkred",cbPalette[6],cbPalette[7],cbPalette[8],"#999999"), name="Pool") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab(expression("C stock (kg C " ~ m^{2} ~ ")")) +
  scale_x_discrete(name = "Latitude", breaks = ybreaks, drop=FALSE, labels = ylabels) +
  coord_flip())
dev.off()
```

##Turnover time plots
```{r}
#Load synthesis of turnover time from Chen et al. (2013). The data is included as Appendix A to the paper in Global & Planetary Change available at the journal's website: https://www.sciencedirect.com/science/article/pii/S0921818112001956?casa_token=ItqTpDc6MuoAAAAA:W3dWe4uKexGd_A3tMnoW8zkORxm-VW4QsbbbaWZSiDNK0AunoFVv2hkUM1iDfbsHmGzNnD0jnA 
chen_mrt <- read.csv(paste0(datadir, "Chen_et_al_2013_GPC.csv"))
length(chen_mrt[!is.na(chen_mrt$MRT_yr),]$MRT_yr)

    load(file=paste0("MRT_all.Rdata"))
    mrt.df <- as.data.frame(rbind(cbind(MRT_mean, rep("all", length(MRT_mean))), cbind(chen_mrt$MRT_yr, rep("Chen", length(chen_mrt$MRT_yr)))))
    load(file=paste0("MRTCentury_all.Rdata"))
    mrt.df <- rbind(mrt.df, cbind(MRT_mean, rep("Century", length(MRT_mean))))

names(mrt.df) <- c("MRT","Dataset")
mrt.df$MRT <- as.numeric(as.character(mrt.df$MRT))
mrt.df$Dataset <- factor(mrt.df$Dataset, levels=c("Chen","Viscarra-Rossel","Georgiou","LUCAS","Century","all"), labels=c("Observed","Viscarra-Rossel","Georgiou","LUCAS","Century","Millennial V2"))

#Make a density histogram of turnover times observed in Chen et al. (2013), modeled by Century, and modeled by Millennial V2 - Figure 9 in Abramoff et al. (2021)
p3 <- ggplot(mrt.df, aes(MRT, fill = Dataset, colour = Dataset)) +
  geom_density(alpha = 0.1) +
  xlim(0,100) +
  scale_fill_manual(values = c(cbPalette[3], cbPalette[4], cbPalette[2]), name="", labels =c("Observed", "Century", "Millennial V2")) +
  scale_color_manual(values = c(cbPalette[3], cbPalette[4], cbPalette[2]), name="", labels =c("Observed", "Century", "Millennial V2")) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab("Density") +
  xlab("Turnover Time (years)")

pdf(file=paste0(figdir,"Figure9.pdf"), height=2.5, width=5)
p3
dev.off()

summary(mrt.df$MRT[mrt.df$Dataset=="Observed"])
summary(mrt.df$MRT[mrt.df$Dataset=="Millennial V2"])
summary(mrt.df$MRT[mrt.df$Dataset=="Century"])
```

##Nutrients exporation
```{r}
#In response to a question about nutrients brought up during review, we explored whether or not there was a relationship between model bias and the N content or C:N ratio of POM and bulk soil
all.V2 <- plot.all[plot.all$Dataset=="All" & plot.all$Source == "V2.5pool.MMRMM",]
all.Century <- plot.all[plot.all$Dataset=="All" & plot.all$Source == "Century",]
all.Observed <- plot.all[plot.all$Dataset=="All" & plot.all$Source == "Observed",]
plot(all.Observed$SOM_kg, all.V2$SOM_kg)
plot(all.V2$SOM/1000, all.V2$SOM_kg)

all.V2$SOMbias <- all.V2$SOM/1000 - all.V2$SOM_kg
all.V2$Bulk.CN <- all.V2$Bulk.C/all.V2$Bulk.N
all.V2$POM.CN <- all.V2$OC_pom_g_kg/all.V2$N_pom_g_kg

all.Century$SOMbias <- all.Century$SOM/1000 - all.Century$SOM_kg
all.Century$Bulk.CN <- all.Century$Bulk.C/all.Century$Bulk.N
all.Century$POM.CN <- all.Century$OC_pom_g_kg/all.Century$N_pom_g_kg

fit1 <- lm(all.V2$SOMbias ~ all.V2$Bulk.CN)
fit2 <- lm(all.V2$SOMbias ~ all.V2$Bulk.C)
fit3 <- lm(all.V2$SOMbias ~ all.V2$Bulk.N)
fit4 <- lm(all.V2$SOMbias ~ all.V2$POM.CN)

fit5 <- lm(all.Century$SOMbias ~ all.Century$Bulk.CN)
fit6 <- lm(all.Century$SOMbias ~ all.Century$Bulk.C)
fit7 <- lm(all.Century$SOMbias ~ all.Century$Bulk.N)
fit8 <- lm(all.Century$SOMbias ~ all.Century$POM.CN)

#Make plots
pdf(file=paste0(figdir,"Figure_Nutrients_Georgiou.pdf"), height=4, width=5)
par(mar = c(3.5,3.7,2,0)+.9)
par(oma = c(0,0,0,0))
plot(all.V2$Bulk.CN, all.V2$SOMbias, xlab = "Bulk Soil C:N", ylab=expression("C stock bias (kg C " ~ m^{2} ~ ")")) #Georgiou only
points(all.Century$Bulk.CN, all.Century$SOMbias, col="darkred")
legend("topright", c("Millennial V2", "Century"), col=c(1, "darkred"), pch=1)
abline(fit1)
abline(fit5, col="darkred")
dev.off()

pdf(file=paste0(figdir,"Figure_Carbon_Georgiou.pdf"), height=4, width=5)
par(mar = c(3.5,3.7,2,0)+.9)
par(oma = c(0,0,0,0))
plot(all.V2$Bulk.C, all.V2$SOMbias, xlab = "Bulk Soil C (g C/kg soil)", ylab=expression("C stock bias (kg C " ~ m^{2} ~ ")")) #Georgiou only
points(all.Century$Bulk.C, all.Century$SOMbias, col="darkred")
legend("topright", c("Millennial V2", "Century"), col=c(1, "darkred"), pch=1)
abline(fit2)
abline(fit6, col="darkred")
dev.off()

pdf(file=paste0(figdir,"Figure_Nitrogen_Georgiou.pdf"), height=4, width=5)
par(mar = c(3.5,3.7,2,0)+.9)
par(oma = c(0,0,0,0))
plot(all.V2$Bulk.N, all.V2$SOMbias, xlab = "Bulk Soil N (g N/kg soil)", ylab=expression("C stock bias (kg C " ~ m^{2} ~ ")")) #Georgiou only
points(all.Century$Bulk.N, all.Century$SOMbias, col="darkred")
legend("topright", c("Millennial V2", "Century"), col=c(1, "darkred"), pch=1)
abline(fit3)
abline(fit7, col="darkred")
dev.off()

pdf(file=paste0(figdir,"Figure_Nutrients_LUCAS.pdf"), height=4, width=5)
par(mar = c(3.5,3.7,2,0)+.9)
par(oma = c(0,0,0,0))
plot(all.V2$POM.CN, all.V2$SOMbias, xlab = "POM C:N", ylab=expression("C stock bias (kg C " ~ m^{2} ~ ")")) #LUCAS only
points(all.Century$POM.CN, all.Century$SOMbias, col="darkred")
legend("topright", c("Millennial V2", "Century"), col=c(1, "darkred"), pch=1)
abline(fit4)
abline(fit8, col="darkred")
dev.off()
```

#Sensitivity to inputs for Century
#Load Century
```{r}
derivs.Century <- function(step.num,state,parameters) {
  with(as.list(c(state,parameters)), {

#Equation B1
  t_scalar <- (parameters$t2 + (parameters$t3 / pi) * atan(pi * parameters$t4 * (forc_st(step.num) - parameters$t1))) /
    (parameters$t2 + (parameters$t3 / pi) * atan(pi * parameters$t4 *(30.0 - parameters$t1)))

#Equation B2
  w_scalar <- 1.0 / (1.0 + parameters$w1 * exp(-parameters$w2 * forc_sw(step.num)/0.39))

#Equation B3
  f_TEX = parameters$c1 - parameters$c2*parameters$clay_silt*0.01
  
#Equation B4
  f_StrLitter = StrLitter * parameters$k_strlitter * t_scalar * w_scalar * exp(-3*parameters$LigFrac)
  
#Equation B5
  f_MetLitter = MetLitter * parameters$k_metlitter * t_scalar * w_scalar  
  
#Equation B6
  f_ACTIVE <- ACTIVE * parameters$k_active * t_scalar * w_scalar * f_TEX
    
#Equation B7
  f_SLOW <- SLOW * parameters$k_slow * t_scalar * w_scalar
  
#Equation B8
  f_PASSIVE <- PASSIVE * parameters$k_passive * t_scalar * w_scalar
  
#Equation B9
  dStrLitter = parameters$input_to_strlitter * forc_npp(step.num) - f_StrLitter
  
#Equation B10
  dMetLitter = (1-parameters$input_to_strlitter) * forc_npp(step.num) - f_MetLitter
  
#Equation B11
  dACTIVE <- (1-parameters$LigFrac) * parameters$strlitter_to_active * f_StrLitter + parameters$metlitter_to_active * f_MetLitter  + f_SLOW * parameters$slow_to_active + f_PASSIVE * parameters$passive_to_active - f_ACTIVE

#Equation B12
  dSLOW <-  parameters$LigFrac * parameters$strlitter_to_slow * f_StrLitter + f_ACTIVE * (1-f_TEX-parameters$active_to_passive) - f_SLOW

#Equation B13
  dPASSIVE <- f_ACTIVE * parameters$active_to_passive + f_SLOW * parameters$slow_to_passive - f_PASSIVE
            
    return(list(c(dStrLitter, dMetLitter, dACTIVE, dSLOW, dPASSIVE)))
  })
}

```

##Run sensitivity to inputs analysis
```{r}
#Plot equilibrium value of different models as a function of litter, soil temperature, and water content

    stateSS <- c(StrLitter=1, MetLitter=1, ACTIVE=1, SLOW=1, PASSIVE=1)
    derivsSS <- derivs.Century
    paramsSS <- parameters[[5]]

SSeq <- NULL
range_forc_st <- seq(from = range(obsdf$SoilTMP_C)[1], to= range(obsdf$SoilTMP_C)[2], length.out = 10)
range_forc_sw <- seq(from = range(obsdf$SoilMoi_m3m3)[1], to= range(obsdf$SoilMoi_m3m3)[2], length.out = 10)
range_forc_npp <- seq(from = range(obsdf$NPP.gC.m2.d)[1], to= range(obsdf$NPP.gC.m2.d)[2], length.out = 10)
range_parm_clay <- seq(from=range(obsdf$ClaySilt)[1], to=range(obsdf$ClaySilt)[2], length.out = 10)

EqRuns <- matrix(nrow=length(range_forc_st)*length(range_forc_sw)*length(range_forc_npp)*length(range_parm_clay), ncol=10)

ptm <- proc.time()
for (n in 1:length(range_parm_clay)){
  paramsSS$clay_silt <- range_parm_clay[n]
    for (l in 1:length(range_forc_npp)){
      forc_npp <- approxfun(1:SStime, rep(range_forc_npp[l],SStime))
          for (k in 1:length(range_forc_sw)){  
          forc_sw <- approxfun(1:SStime, rep(range_forc_sw[k],SStime))
              for (j in 1:length(range_forc_st)){
              forc_st <- approxfun(1:SStime, rep(range_forc_st[j],SStime)) 
              
                  SSeq <- stode(y = stateSS, time = SStime, func = derivsSS, parms = paramsSS, positive=TRUE)
                  
                  SSindex <- j + length(range_forc_st)*(k-1) + length(range_forc_st)*length(range_forc_npp)*(l-1) + length(range_forc_st)*length(range_forc_npp)*length(range_parm_clay)*(n-1)
                      EqRuns[SSindex,] <- c("Century", forc_st(1), forc_sw(1), forc_npp(1), range_parm_clay[n], SSeq$y)
              
              }
          }
      }
  }
proc.time() - ptm

EqRuns <- as_tibble(EqRuns) %>%
  dplyr::rename( models=V1, forc_st=V2, forc_sw=V3, forc_npp=V4, parm_clay=V5, StrLitter=V6, MetLitter=V7, ACTIVE=V8, SLOW=V9, PASSIVE=V10) %>%
  dplyr::mutate_at( vars(forc_st, forc_sw, forc_npp,StrLitter, MetLitter, ACTIVE, SLOW, PASSIVE), as.numeric)

 EqRuns <- EqRuns %>% gather(pool, value, StrLitter:PASSIVE)

save(EqRuns,file="Millennial_Version_Analysis_EqRuns_extralongs_Century.Rdata")
```

##Plot sensitivity to inputs
```{r}
#Load output in case chunk is run separately from previous
load(file="Millennial_Version_Analysis_EqRuns_extralongs_Century.Rdata")
EqRuns$parm_clay <- as.numeric(EqRuns$parm_clay)
centwidth = 9
centheight = 2.5
EqRuns$pool <- factor(EqRuns$pool,levels = c("StrLitter", "MetLitter", "ACTIVE", "SLOW", "PASSIVE"))

#Together these plots are Figure S4 in Abramoff et al. (2021)
#Plot sensitivity of model pools to temperature at equilibrium
pdf(file=paste0(figdir,"FigureS4a.pdf"), height=centheight, width=centwidth)
print(ggplot(EqRuns) +
    geom_smooth( aes(x=forc_st, y=value ), color="black") +
    theme_classic() + 
      theme(panel.grid = element_blank(), axis.text = element_text(size=10), axis.title = element_text(size=15), strip.text = element_text(size=15)) +
  ylab(expression("SOC (gC" ~ m^{-2} ~ ")")) +
  xlab(expression("Temperature (" ~ degree ~ "C)")) + 
  facet_wrap(pool ~ ., scales="free_y",nrow=1))
dev.off()

#Plot sensitivity of model pools to VWC at equilibrium
pdf(file=paste0(figdir,"FigureS4b.pdf"), height=centheight, width=centwidth)
print(ggplot(EqRuns) +
    geom_smooth( aes(x=forc_sw, y=value ), color="black") +
      theme_classic() + 
            theme(panel.grid = element_blank(), axis.text = element_text(size=10), axis.title = element_text(size=15), strip.text = element_text(size=15)) +
  ylab(expression("SOC (gC" ~ m^{-2} ~ ")")) +
  xlab(expression("VWC (" ~ m^{3} ~ m^{-3} ~ ")")) +
  facet_wrap(pool ~ ., scales="free_y",nrow=1))
dev.off()

#Plot sensitivity of model pools to litter inputs at equilibrium
pdf(file=paste0(figdir,"FigureS4c.pdf"), height=centheight, width=centwidth)
print(ggplot(EqRuns) +
    geom_smooth( aes(x=forc_npp, y=value ), color="black") +
      theme_classic() + 
            theme(panel.grid = element_blank(), axis.text = element_text(size=10), axis.title = element_text(size=15), strip.text = element_text(size=15)) +
  ylab(expression("SOC (gC" ~ m^{-2} ~ ")")) +
  xlab(expression("NPP (gC" ~ m^{-2} ~ d^{-1} ~ ")")) +
  facet_wrap(pool ~ ., scales="free_y",nrow=1))
dev.off()

#Plot sensitivity of model pools to clay at equilibrium
pdf(file=paste0(figdir,"FigureS4d.pdf"), height=centheight, width=centwidth)
print(ggplot(EqRuns) +
    geom_smooth( aes(x=parm_clay, y=value ), color="black") +
      theme_classic() + 
            theme(panel.grid = element_blank(), axis.text = element_text(size=10), axis.title = element_text(size=15), strip.text = element_text(size=15)) +
  ylab(expression("SOC (gC" ~ m^{-2} ~ ")")) +
  xlab(expression("% Clay & Silt")) +
  facet_wrap(pool ~ ., scales="free_y",nrow=1))
dev.off()

#Similar to the plots above, but with all pools on the same plot rather than each pool as a facet
g1 <- ggplot(EqRuns) +
    geom_smooth( aes(x=forc_st, y=value, color=pool )) +
    theme_classic() + 
      theme(panel.grid = element_blank(), axis.text = element_text(size=10), axis.title = element_text(size=15), strip.text = element_text(size=15), legend.position = "none") +
  scale_color_manual(values = mypal) + 
  ylab(expression("SOC (gC" ~ m^{-2} ~ ")")) +
  xlab(expression("Temperature (" ~ degree ~ "C)"))

g2 <- ggplot(EqRuns) +
    geom_smooth( aes(x=forc_sw, y=value, color=pool )) +
      theme_classic() + 
            theme(panel.grid = element_blank(), axis.text = element_text(size=10), axis.title = element_text(size=15), strip.text = element_text(size=15), legend.position = "none") +
  scale_color_manual(values = mypal) + 
  ylab(expression("SOC (gC" ~ m^{-2} ~ ")")) +
  xlab(expression("VWC (" ~ m^{3} ~ m^{-3} ~ ")"))

 g3 <- ggplot(EqRuns) +
    geom_smooth( aes(x=forc_npp, y=value, color=pool )) +
      theme_classic() + 
            theme(panel.grid = element_blank(), axis.text = element_text(size=10), axis.title = element_text(size=15), strip.text = element_text(size=15), legend.position = "none") +
  scale_color_manual(name="Pool", values = mypal) + 
  ylab(expression("SOC (gC" ~ m^{-2} ~ ")")) +
  xlab(expression("NPP (gC" ~ m^{-2} ~ d^{-1} ~ ")"))
 
   g5 <- ggplot(EqRuns) +
    geom_smooth( aes(x=parm_clay, y=value, color=pool )) +
      theme_classic() + 
            theme(panel.grid = element_blank(), axis.text = element_text(size=10), axis.title = element_text(size=15), strip.text = element_text(size=15), legend.position = "none") +
  scale_color_manual(name="Pool", values = mypal) + 
  ylab(expression("SOC (gC" ~ m^{-2} ~ ")")) +
  xlab(expression("% Clay & Silt"))
 
 g.legend <- ggplot(EqRuns) +
    geom_smooth( aes(x=forc_st, y=value, color=pool )) +
      theme(panel.grid = element_blank(), strip.text = element_text(size=15)) +
  scale_color_manual(name = "Pool", values = mypal)

#Plot sensitivity of model pools to inputs together
pdf(file=paste0(figdir,"eq_plots_compressed_all_Cent.pdf"), height=4, width=centwidth)
multiplot(g1, g5, g2, g2, g3, cols=3)
dev.off()

pdf(file=paste0(figdir,"eq_plots_legend_all_Cent.pdf"), height=4, width=4)
print(g.legend)
dev.off()
```

